/*
 * Tencent is pleased to support the open source community by making Puerts available.
 * Copyright (C) 2020 THL A29 Limited, a Tencent company.  All rights reserved.
 * Puerts is licensed under the BSD 3-Clause License, except for the third-party components listed in the file 'LICENSE' which may be subject to their corresponding license terms. 
 * This file is subject to the terms and conditions defined in file 'LICENSE', which is part of this source code package.
 */

var global = global || (function () { return this; }());
(function (global) {
    "use strict";
    
    function csTypeToClass(csType) {
        let cls = puerts.loadType(csType);
        
        if (cls) {
            let parentPrototype = Object.getPrototypeOf(cls.prototype);
            if (parentPrototype) {
                Object.setPrototypeOf(cls, parentPrototype.constructor);//v8 api的inherit并不能把静态属性也继承，通过这种方式修复下
            }

            for(var key in cls) {
                let desc = Object.getOwnPropertyDescriptor(cls, key);
                if (desc && desc.configurable && (typeof desc.get) == 'function' && (typeof desc.value) == 'undefined') {
                    let val = cls[key];
                    Object.defineProperty(cls, key, {
                        value: val,
                        writable: false,
                        configurable: false
                    });
                    if (cls.__p_isEnum && (typeof val) == 'number') {
                        cls[val] = key;
                    }
                }
            }

            let nestedTypes = puerts.getNestedTypes(csType);
            if (nestedTypes) {
                for(var i = 0; i < nestedTypes.Length; i++) {
                    let ntype = nestedTypes.get_Item(i);
                    cls[ntype.Name] = csTypeToClass(ntype);
                }
            }
        }
        return cls;
    }

    function Namespace() {}
    function createTypeProxy(namespace) {
        return new Proxy(new Namespace, {
            get: function(cache, name) {
                if (!(name in cache)) {
                    let fullName = namespace ? (namespace + '.' + name) : name;
                    if (/\$\d+$/.test(name)) {
                        let genericTypeInfo = new Map();
                        genericTypeInfo.set('$name', fullName.replace('$', '`'));
                        cache[name] = genericTypeInfo;
                    } else {
                        let cls = csTypeToClass(fullName);
                        if (cls) {
                            cache[name] = cls;
                        } else {
                            cache[name] = createTypeProxy(fullName);
                            //console.log(fullName + ' is a namespace');
                        }
                    }
                }
                return cache[name];
            }
        });
    }
    
    let csharpModule = createTypeProxy(undefined);
    puerts.registerBuildinModule('csharp', csharpModule);
    
    csharpModule.System.Object.prototype.toString = csharpModule.System.Object.prototype.ToString;
    
    function ref(x) {
        return {value:x};
    }

    function unref(r) {
        return r.value;
    }
    
    function setref(x, val) {
        x.value = val;
    }
    
    function taskToPromise(task) {
        return new Promise((resolve, reject) => {
            task.GetAwaiter().OnCompleted(() => {
                let t = task;
                task = undefined;
                if (t.IsFaulted) {
                    if (t.Exception) {
                        if (t.Exception.InnerException) {
                            reject(t.Exception.InnerException.Message);
                        } else {
                            reject(t.Exception.Message);
                        }
                    } else {
                        reject("unknow exception!");
                    }
                } else {
                    resolve(t.Result);
                }
            });
        });
    }
    
    function makeGeneric(genericTypeInfo, ...genericArgs) {
        let p = genericTypeInfo;
        for (var i = 0; i < genericArgs.length; i++) {
            let genericArg = genericArgs[i];
            if (!p.get(genericArg)) {
                p.set(genericArg, new Map());
            }
            p = p.get(genericArg);
        }
        if (!p.get('$type')) {
            p.set('$type', puerts.loadType(genericTypeInfo.get('$name'), ...genericArgs));
        }
        return p.get('$type');
    }
    
    function getType(cls) {
        return cls.__p_innerType;
    }
    
    function csharpToMatchType(type) {
        switch (type.FullName) {
            case "System.Int64":
            case "System.UInt64":
                return "bigint";
            case "System.Byte":
            case "System.SByte":
            case "System.Char":
            case "System.Int16":
            case "System.Int32":
            case "System.UInt16":
            case "System.UInt32":
            case "System.Single":
            case "System.Double":
                return "number";
            case "System.Boolean":
                return "boolean";
            case "System.String":
                return "string";
            case "System.DateTime":
                return "Date";
            case "Puerts.ArrayBuffer":
                return "ArrayBuffer";
            case "Puerts.JSObject":
                return "JSObject";
            case "System.Object":
                return "any";
        }
        if (getType(require("csharp").System.Delegate).IsAssignableFrom(type)) {
            return "function";
        }
        return type;
    }
    function jsToMatchType(arg) {
        let type = typeof arg;
        if (type === "object") {
            if (arg instanceof require("csharp").System.Object)
                return csharpToMatchType(arg.GetType());
            if (arg instanceof ArrayBuffer) {
                return "ArrayBuffer";
            }
            else if (arg instanceof Date) {
                return "Date";
            }
            return "JSObject";
        }
        if (type === "undefined") {
            return "any";
        }
        return type;
    }
    const methodFlags = 8 | 16, extensionCompleted = Symbol("%method extensions infos%");
    function creatMatchInfos(matchInfos, cls, extension) {
        function pushLen(matchInfo, matchParams) {
            let matchLen = matchInfo[matchParams.length];
            if (!matchLen) {
                matchLen = matchInfo[matchParams.length] = [];
            }
            matchLen.push(matchParams);
        }
        ;
        let clsType = getType(cls), extensionType = getType(extension);
        let methodInfos = extensionType.GetMethods(methodFlags);
        for (let i = 0; i < methodInfos.Length; i++) {
            let methodInfo = methodInfos.get_Item(i), params = methodInfo.GetParameters();
            if (params.Length === 0)
                continue;
            let firstParam = params.get_Item(0);
            if (!(clsType.IsAssignableFrom(firstParam.ParameterType) ||
                methodInfo.IsGenericMethod && firstParam.ParameterType.IsGenericParameter))
                continue;
            let matchInfo = matchInfos.get(methodInfo.Name);
            if (!matchInfo) {
                matchInfo = {
                    match: function (args) {
                        let len = args.length;
                        let matchParams = this[len];
                        if (!matchParams)
                            return false;
                        if (len === 0)
                            return true;
                        let argTypes = args.map(arg => jsToMatchType(arg));
                        for (let _matchParams of matchParams) {
                            for (let i = 0; i < len; i++) {
                                let mp = _matchParams[i], ap = argTypes[i];
                                if (typeof mp === "string" && typeof ap === "string") {
                                    if (mp !== ap)
                                        break;
                                }
                                else if (typeof mp === "object" && typeof ap === "object") {
                                    if (!mp.IsAssignableFrom(ap))
                                        break;
                                }
                                if (i === len - 1)
                                    return true;
                            }
                        }
                        return false;
                    }
                };
                matchInfos.set(methodInfo.Name, matchInfo);
            }
            let matchParams = new Array();
            for (let i = 1; i < params.Length; i++) {
                let param = params.get_Item(i);
                if (param.IsOptional) {
                    pushLen(matchInfo, matchParams);
                    matchParams = [...matchParams];
                }
                ;
                matchParams.push(csharpToMatchType(param.ParameterType));
            }
            pushLen(matchInfo, matchParams);
        }
    }
    function isMatch(matchInfos, cls, extension, methodName, args) {
        let completedInfos = cls[extensionCompleted];
        if (!completedInfos) {
            completedInfos = cls[extensionCompleted] = new Array();
        }
        if (completedInfos.indexOf(extension) < 0) {
            completedInfos.push(extension);
            creatMatchInfos(matchInfos, cls, extension);
        }
        let matchInfo = matchInfos.get(methodName);
        if (matchInfo) {
            return matchInfo.match(args);
        }
        return false;
    }
    function extension(cls, extension) {
        let matchInfos = new Map();
        Object.keys(extension).forEach(key => {
            let func = extension[key];
            if (typeof (func) !== "function" || key === "constructor")
                return;
            let proto = cls.prototype, srcFunc;
            if ((srcFunc = proto[key])) {
                let newProto = Object.create(Object.getPrototypeOf(proto));
                Object.setPrototypeOf(proto, newProto);
                proto = newProto;
            }
            Object.defineProperty(proto, key, {
                value: function (...args) {
                    if (isMatch(matchInfos, cls, extension, key, args)) {
                        return func.call(null, this, ...args);
                    }
                    else if (srcFunc) {
                        return srcFunc.apply(this, args);
                    }
                    else {
                        throw new Error(`invalid arguments to ${key}`);
                    }
                },
                writable: false,
                configurable: false
            });
        });
    }
    
    puerts.$ref = ref;
    puerts.$unref = unref;
    puerts.$set = setref;
    puerts.$promise = taskToPromise;
    puerts.$generic = makeGeneric;
    puerts.$typeof = getType;
    puerts.$extension = extension;

}(global));
