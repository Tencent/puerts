{{
function parameterDef(pinfo) {
    return (pinfo.IsParams ? ("..." + pinfo.Name) : "$" + pinfo.Name) + (pinfo.IsOptional?"?":"") + ": " + pinfo.TypeName;
}
function typeKeyword(type) {
    if (type.IsDelegate) {
        return 'type';
    } else if (type.IsInterface) {
        return 'interface';
    } else if (type.IsEnum) {
        return 'enum';
    } else {
        return 'class'
    }
}

function typeDeclaration(type, level1) {
    var result = type.Name;
    if (type.IsGenericTypeDefinition) {
        result += "<" + Array.prototype.join.call(type.GenericParameters, ',') + ">";
    }
    if (level1 && type.BaseType) {
        result += " extends " + typeDeclaration(type.BaseType);
    }
    if(!level1 && type.Namespace) {
        result = type.Namespace + "." + result;
    }
    return result;
}

function typeProperty(type, property, space) {
    if (type.IsInterface || property.IsField) {
        return property.Name + ": " + property.TypeName;
    }
    let _static = property.IsStatic ? "static " : "";
    let set = "public " + _static + "set " + property.Name + "(val: " + property.TypeName + ")";
    if (!property.HasGetter) {
        return set;
    }
    let get = "public " + _static + "get " + property.Name + "(): " + property.TypeName;
    if (!property.HasSetter) {
        return get;
    }
    return get + ";\n" + (space ?? "") + set;
}
}}
declare module 'csharp' {
    interface $Ref<T> {
        value: T
    }
    
    namespace System {
        interface Array$1<T> extends System.Array {
            get_Item(index: number):T;
            
            set_Item(index: number, value: T):void;
        }
    }
    
    {{=it.TaskDef}}
    
    {{~it.NamespaceInfos :ns}}{{?ns.Name}}namespace {{=ns.Name}} {{{?}}
        {{~ns.Types :type}}{{=typeKeyword(type)}} {{=typeDeclaration(type, true)}} {{if(type.IsDelegate){}}= {{=type.DelegateDef}};{{?!type.IsGenericTypeDefinition}}
        var {{=type.Name}}: {new (func: {{=type.DelegateDef}}): {{=type.Name}};}{{?}}{{ } else if(type.IsEnum) { }}{ {{=type.EnumKeyValues}} }{{ }else{ }}{
            {{~type.Properties :property}}{{=typeProperty(type, property, "\t\t\t\t")}};
            {{~}}{{~type.Methods :method}}{{?!type.IsInterface}}public {{?}}{{?method.IsStatic}}static {{?}}{{=method.Name}}({{~method.ParameterInfos :pinfo:idx}}{{?idx>0}}, {{?}}{{=parameterDef(pinfo)}}{{~}}){{=method.IsConstructor?"":":" + method.TypeName}};
            {{~}}
        }{{}}}{{?type.ExtensionMethods.length > 0}}
        interface {{=type.Name}} {
            {{~type.ExtensionMethods :method}}{{=method.Name}}({{~method.ParameterInfos :pinfo:idx}}{{?idx>0}}, {{?}}{{=parameterDef(pinfo)}}{{~}}):{{=method.TypeName}};
            {{~}}
        }
        {{?}}
        {{~}}
    {{?ns.Name}}}{{?}}
    {{~}}
}