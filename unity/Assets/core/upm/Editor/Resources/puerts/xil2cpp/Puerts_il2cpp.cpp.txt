/*
 * Tencent is pleased to support the open source community by making Puerts available.
 * Copyright (C) 2020 THL A29 Limited, a Tencent company.  All rights reserved.
 * Puerts is licensed under the BSD 3-Clause License, except for the third-party components listed in the file 'LICENSE' which may
 * be subject to their corresponding license terms. This file is subject to the terms and conditions defined in file 'LICENSE',
 * which is part of this source code package.
 */

#include "unityenv_for_puerts.h"
#include "il2cpp-config.h"
#include "codegen/il2cpp-codegen.h"

#include "il2cpp-api.h"
#include "il2cpp-class-internals.h"
#include "il2cpp-object-internals.h"
#include "mono-structs.h"
#include "vm/InternalCalls.h"
#include "vm/Object.h"
#include "vm/Array.h"
#include "vm/Runtime.h"
#include "vm/Reflection.h"
#include "vm/MetadataCache.h"
#include "vm/Field.h"
#include "vm/GenericClass.h"
#include "vm/Thread.h"
#include "vm/Method.h"
#include "vm/Parameter.h"
#include "vm/Image.h"
#include "vm/GenericContainer.h"
#include "utils/StringUtils.h"
#include "gc/WriteBarrier.h"
#include "gc/GCHandle.h"
#include "pesapi.h"
#include "TDataTrans.h"

#include <vector>
#include <mutex>
#include <map>
#include <string>
#include <unordered_set>
#include <sstream>
#if defined(__EMSCRIPTEN__)
#include "pesapi_webgl.h"
using namespace pesapi::webglimpl;
#endif

// Because we need to hold the C# object pointer, we must ensure that GC does not do memory reorganization.
static_assert(IL2CPP_GC_BOEHM, "Only BOEHM GC supported!");

using namespace il2cpp::vm;

namespace puerts
{
struct CSharpMethodInfo
{
    std::string Name;
    bool IsStatic;
    bool IsGetter;
    bool IsSetter;
    bool NeedBoxing;
    std::vector<WrapData*> OverloadDatas;
};

struct CSharpFieldInfo
{
    std::string Name;
    bool IsStatic;
    FieldWrapData *Data;
};

struct JsClassInfoHeader
{
    Il2CppClass* TypeId;
    Il2CppClass* SuperTypeId;
    bool IsValueType;
    Il2CppMethodPointer DelegateBridge;
    WrapData** CtorWrapDatas;
};

WrapFuncPtr FindWrapFunc(const char* signature);
struct FieldWrapFuncInfo * FindFieldWrapFuncInfo(const char* signature);
Il2CppMethodPointer FindBridgeFunc(const char* signature);

struct JsClassInfo : public JsClassInfoHeader
{
    std::string Name;
    std::vector<WrapData*> Ctors;
    std::vector<CSharpMethodInfo> Methods;
    std::vector<CSharpFieldInfo> Fields;
};

const Il2CppClass* CSharpTypeToTypeId(Il2CppObject *type)
{
    return (type && Class::IsAssignableFrom(il2cpp_defaults.systemtype_class, type->klass)) ? il2cpp_codegen_class_from_type(((Il2CppReflectionType *)type)->type) : nullptr;
}

static void* ObjectAllocate(Il2CppClass *klass)
{
    if (Class::IsValuetype(klass))
    {
        auto size = klass->native_size > 0 ? klass->native_size : (klass->instance_size - sizeof(Il2CppObject));
        auto buff = (void*)(new uint8_t[size]);
        memset(buff, 0, size);
        return buff;
    } else {
        auto obj = il2cpp::vm::Object::New(klass);
        return obj;
    }
}

static void ValueTypeFree(void* ptr)
{
    delete [] (uint8_t*)ptr;
}

static void PApiFree(struct pesapi_ffi* api, void* ptr, void* class_data, void* env_private)
{
    ValueTypeFree(ptr); //TODO: class_data->IsValueType
}

static Il2CppClass *g_typeofPersistentObjectInfo;
static Il2CppClass *g_typeofArrayBuffer;
static FieldInfo* g_arrayBufferCountField = nullptr;
static FieldInfo* g_arrayBufferBytesField = nullptr;
static Il2CppClass *g_typeofTypedValue;

static MethodInfoHelper<Il2CppArray*(Il2CppString*)> g_ExtensionMethodGetHelper;

static Il2CppClass* s_ParamArrayAttribute;
static Il2CppClass* s_ExtensionAttribute;

static bool RegisterType(Il2CppClass* klass);
static bool ClassNotFoundCallback(const void* typeId)
{
    return RegisterType((Il2CppClass*)typeId);
}

static void SetExtensionMethodGet(Il2CppReflectionMethod* method)
{
    g_ExtensionMethodGetHelper = MethodInfoHelper<Il2CppArray*(Il2CppString*)>(method->method);
}

static std::string GetTypeSignature(const Il2CppType* type);

static bool IsPtrToSelf(const Il2CppType* type, const Il2CppClass* selfClass)
{
    if (type->byref && (type->type == IL2CPP_TYPE_VALUETYPE || type->type == IL2CPP_TYPE_TYPEDBYREF))
    {
        Il2CppClass* klass = Class::FromIl2CppType(type, false);
        Class::Init(klass);
        return Class::FromIl2CppType(&(klass->byval_arg)) == selfClass;
    }
    if (type->type == IL2CPP_TYPE_PTR)
    {
        Il2CppClass* klass = Class::FromIl2CppType(type, false);
        Class::Init(klass);
        return klass->element_class == selfClass;
    }
    return false;
}

static std::string GetValueTypeFieldsSignature(const Il2CppType* type)
{
    Il2CppClass* klass = Class::FromIl2CppType(type, false);
    Class::Init(klass);
    std::string ret = "";
    for (uint16_t index = 0; index < klass->field_count; index++)
    {
        FieldInfo* field = klass->fields + index;
        if (field->type->attrs & FIELD_ATTRIBUTE_STATIC) continue;
        if (IsPtrToSelf(field->type, klass))
        {
            ret += "Pv";
        }
        else
        {
            ret += GetTypeSignature(field->type);
        }
    }
    return ret;
}

static std::string GetTypeSignature(const Il2CppType* type)
{
    std::string ret;
    switch (type->type)
    {
    case IL2CPP_TYPE_VOID:
    {
        ret = "v";
        break;
    }
    case IL2CPP_TYPE_BOOLEAN:
    {
        ret = "b";
        break;
    }
    case IL2CPP_TYPE_U1:
    {
        ret = "u1";
        break;
    }
    case IL2CPP_TYPE_I1:
    {
        ret = "i1";
        break;
    }
    case IL2CPP_TYPE_I2:
    {
        ret = "i2";
        break;
    }
    case IL2CPP_TYPE_U2:
    {
        ret = "u2";
        break;
    }
    case IL2CPP_TYPE_I4:
    {
        ret = "i4";
        break;
    }
    case IL2CPP_TYPE_U4:
    {
        ret = "u4";
        break;
    }
    case IL2CPP_TYPE_I8:
    {
        ret = "i8";
        break;
    }
    case IL2CPP_TYPE_U8:
    {
        ret = "u8";
        break;
    }
    case IL2CPP_TYPE_CHAR:
    {
        ret = "c";
        break;
    }
    case IL2CPP_TYPE_R8:
    {
        ret = "r8";
        break;
    }
    case IL2CPP_TYPE_R4:
    {
        ret = "r4";
        break;
    }
    case IL2CPP_TYPE_I:
    case IL2CPP_TYPE_U:
    {
        ret = "p";
        break;
    }
    case IL2CPP_TYPE_STRING:
    {
        ret = "s";
        break;
    }
    case IL2CPP_TYPE_OBJECT: //object特殊处理，比如check可以不用判断，比如return可以优化
    {
        ret = "O";
        break;
    }
    //case IL2CPP_TYPE_BYREF:
    case IL2CPP_TYPE_PTR:
    {
        ret = "P" + GetTypeSignature(type->data.type);
        break;
    }
    //case IL2CPP_TYPE_ENUM:
    //{
    //    ret = GetTypeSignature(Type::GetUnderlyingType(type));
    //    break;
    //}
    case IL2CPP_TYPE_ARRAY:
    case IL2CPP_TYPE_SZARRAY:
    case IL2CPP_TYPE_CLASS:
    {
        Il2CppClass* klass = Class::FromIl2CppType(type, false);
        Class::Init(klass);
        ret = (klass == g_typeofArrayBuffer) ? "a" : "o";
        break;
    }
    case IL2CPP_TYPE_GENERICINST:
    {
        Il2CppClass* klass = Class::FromIl2CppType(type, false);
        Class::Init(klass);
        if (!klass->byval_arg.valuetype)
        {
            ret = "o";
            break;
        }
        // continue with valuetype
    }
    case IL2CPP_TYPE_VALUETYPE:
    case IL2CPP_TYPE_TYPEDBYREF://public ref struct TypedReference {}
    {
        Il2CppClass* klass = Class::FromIl2CppType(type, false);
        Class::Init(klass);

        if (Type::IsEnum(type) || Class::GetParent(klass) == il2cpp_defaults.enum_class)
        {
            auto baseType = Type::GetUnderlyingType(type);
            if (baseType == type)
            {
                Il2CppClass* klass = Class::FromIl2CppType(type, false);
                ret = GetTypeSignature(klass->fields[0].type);
                break;
            }
            ret = GetTypeSignature(baseType);
            break;
        }

        if (il2cpp::vm::Class::IsNullable(klass))
            ret = "N_" + GetValueTypeFieldsSignature(type) + "_";
        else
            ret = "S_" + GetValueTypeFieldsSignature(type) + "_";
        break;
    }
    //case IL2CPP_TYPE_MVAR:
    //case IL2CPP_TYPE_VAR:
    default:
        Exception::Raise(Exception::GetInvalidOperationException("not support type"));
    }
    
    return type->byref ? "P" + ret :  ret;
}

static bool HasParamArray(const MethodInfo* method)
{
    if (method->parameters_count == 0)
    {
        return false;
    }
    
    const MethodInfo* methodWithParameterAttributeInformation = method;
    if (method->is_inflated)
        methodWithParameterAttributeInformation = method->genericMethod->methodDefinition;

#if defined(UNITY_2022_1_OR_NEWER)
    auto reader = il2cpp::vm::MetadataCache::GetCustomAttributeDataReader(methodWithParameterAttributeInformation->klass->image, Method::GetParameterToken(method, method->parameters_count - 1));

    auto ctorIter = reader.GetCtorIterator([](const MethodInfo* ctor) {
        return ctor->klass == s_ParamArrayAttribute;
    });
    const MethodInfo* ctor;
    return (reader.IterateAttributeCtors(&ctor, &ctorIter));
#else
    return (MetadataCache::HasAttribute(methodWithParameterAttributeInformation->klass->image, Method::GetParameterToken(method, method->parameters_count - 1), s_ParamArrayAttribute));
#endif
}

static std::string GetParameterSignature(const MethodInfo* method, int index)
{
    if (kInvalidIl2CppMethodSlot != method->slot) {
        Class::Init(method->klass);
    }
    const Il2CppType* type = Method::GetParam(method, index);
    
    if (type)
    {
        if (type->attrs & PARAM_ATTRIBUTE_OPTIONAL) {
            return "D" + GetTypeSignature(type);
        }

        if ((index == method->parameters_count - 1) && HasParamArray(method))
        {
            Il2CppClass* parameterKlass = Class::FromIl2CppType(type, false);
            return "V" + GetTypeSignature(&parameterKlass->element_class->byval_arg);
        }
        else
        {
            return GetTypeSignature(type);
        }
    }
    else
    {
        Exception::Raise(Exception::GetInvalidOperationException("invalid paramerter index"));
    }
}

static bool IsDelegate(Il2CppClass *klass)
{
    return Class::HasParent(klass, il2cpp_defaults.delegate_class) && klass != il2cpp_defaults.delegate_class && klass != il2cpp_defaults.multicastdelegate_class;
}

static bool IsCtor(const MethodInfo* method)
{
    return *method->name == '.' && strcmp(method->name, ".ctor") == 0;
}

static bool IsCCtor(const MethodInfo* method)
{
    return *method->name == '.' && strcmp(method->name, ".cctor") == 0;
}

static bool IsExtensionMethod(const MethodInfo* method)
{
    return Method::HasAttribute(method, s_ExtensionAttribute);
}

static std::string GetMethodSignature(const MethodInfo* method, bool isBridge, bool isExtensionMethod)
{
    std::string signature = "";
    if (IsCtor(method))
    {
        signature += "vt";
        for(uint32_t i = 0; i < method->parameters_count; ++i)
        {
            signature += GetParameterSignature(method, i);
        }
    }
    else
    {
        signature += GetTypeSignature(method->return_type);
        if (!isBridge && Method::IsInstance(method)) signature += (il2cpp_defaults.object_class == method->klass) ? "T" : "t";
        for (uint32_t i = 0; i < method->parameters_count; ++i)
        {
            if (i == 0 && isExtensionMethod)
            {
                signature += method->parameters[i]->type == IL2CPP_TYPE_OBJECT ? "T" : "t";
            }
            else
            {
                signature += GetParameterSignature(method, i);
            }
        }

    }

    return signature;
}

static Il2CppMethodPointer GetMethodPointer(const MethodInfo* method)
{
    auto ret = MetadataCache::GetMethodPointer(method->klass->image, method->token);
    if (!ret)
    {
        ret = method->methodPointer;
    }
    return ret;
}

Il2CppClass* GetReturnType(const MethodInfo* method) {
    if (kInvalidIl2CppMethodSlot != method->slot) {
        Class::Init(method->klass);
    }
    return Class::FromIl2CppType(Method::GetReturnType(method), false);
}

Il2CppClass* GetParameterType(const MethodInfo* method, int index) {
    if (kInvalidIl2CppMethodSlot != method->slot) {
        Class::Init(method->klass);
    }
    const Il2CppType* type = Method::GetParam(method, index);
    if (type) {
        return Class::FromIl2CppType(type, false);
    } else {
        return nullptr;
    }
}

static std::map<const MethodInfo*, const MethodInfo*> WrapFuncPtrToMethodInfo;
static std::recursive_mutex WrapFuncPtrToMethodInfoMutex;

Il2CppDelegate* FunctionPointerToDelegate(Il2CppMethodPointer functionPtr, Il2CppClass* delegateType, Il2CppObject* target)
{
    Il2CppObject* delegate = il2cpp::vm::Object::New(delegateType);
    const MethodInfo* invoke = il2cpp::vm::Runtime::GetDelegateInvoke(delegateType);

    const MethodInfo* method = NULL;
    {
        std::lock_guard<std::recursive_mutex> lock(WrapFuncPtrToMethodInfoMutex);
        //il2cpp::utils::NativeDelegateMethodCache::GetNativeDelegate((Il2CppMethodPointer)invoke);
        auto iter = WrapFuncPtrToMethodInfo.find(invoke);
        if (iter == WrapFuncPtrToMethodInfo.end())
        {
            MethodInfo* newMethod = (MethodInfo*)IL2CPP_CALLOC(1, sizeof(MethodInfo));
            newMethod->name = invoke->name;
            newMethod->klass = invoke->klass;
            newMethod->methodPointer = functionPtr;
            newMethod->invoker_method = invoke->invoker_method;
            newMethod->return_type = invoke->return_type;
            newMethod->parameters_count = invoke->parameters_count;
            newMethod->parameters = invoke->parameters;
            newMethod->slot = kInvalidIl2CppMethodSlot;
            //newMethod->is_marshaled_from_native = true;
            //il2cpp::utils::NativeDelegateMethodCache::AddNativeDelegate((Il2CppMethodPointer)invoke, newMethod);
            WrapFuncPtrToMethodInfo.insert(std::make_pair(invoke, newMethod));
            method = newMethod;
        }
        else
        {
            method = iter->second;
        }
    }

#ifdef UNITY_2021_1_OR_NEWER
    Type::ConstructClosedDelegate((Il2CppDelegate*)delegate, target, functionPtr, method);
#else
    Type::ConstructDelegate((Il2CppDelegate*)delegate, target, functionPtr, method);
#endif

    return (Il2CppDelegate*)delegate;
}

static void* DelegateAllocate(Il2CppClass *klass, Il2CppMethodPointer functionPtr, PObjectRefInfo** outTargetData)
{
    Il2CppClass *delegateInfoClass = g_typeofPersistentObjectInfo;
    if (!delegateInfoClass) return nullptr;
    
    auto target = il2cpp::vm::Object::New(delegateInfoClass);
    
    Il2CppDelegate* delegate = FunctionPointerToDelegate(functionPtr, klass, target);

    if (MethodIsStatic(delegate->method)) return nullptr;

#ifndef UNITY_2021_1_OR_NEWER
    const MethodInfo* ctor = il2cpp_class_get_method_from_name(delegateInfoClass, ".ctor", 0);
    typedef void (*NativeCtorPtr)(Il2CppObject* ___this, const MethodInfo* method);
    ((NativeCtorPtr)ctor->methodPointer)(target, ctor);

    IL2CPP_OBJECT_SETREF(delegate, target, target);
#endif

    *outTargetData = GetPObjectRefInfo(target);

    delegate->method_ptr = functionPtr;

    return delegate;
}

void SetGlobalType_ArrayBuffer(Il2CppReflectionType *type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of ArrayBuffer is null"));
    }
    g_typeofArrayBuffer =  il2cpp_codegen_class_from_type(type->type);
    g_arrayBufferCountField = il2cpp_class_get_field_from_name(g_typeofArrayBuffer, "Count");
    g_arrayBufferBytesField = il2cpp_class_get_field_from_name(g_typeofArrayBuffer, "Bytes");
}

void SetGlobalType_JSObject(Il2CppReflectionType *type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of JSObject is null"));
    }
    g_typeofPersistentObjectInfo = il2cpp_codegen_class_from_type(type->type);
}

void SetGlobalType_TypedValue(Il2CppReflectionType *type)
{
    if (!type)
    {
        Exception::Raise(Exception::GetInvalidOperationException("type of TypedValue is null"));
    }
    g_typeofTypedValue = il2cpp_codegen_class_from_type(type->type);
}

static void MethodCallback(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    CSharpMethodInfo* csharpMethodInfo = (CSharpMethodInfo*)${invokePapi('get_userdata')}(info);
    try 
    {
        void* self = nullptr;
        pesapi_env env = ${invokePapi('get_env')}(info);
        if (!(csharpMethodInfo->IsStatic))
        {
            self = ${invokePapi('get_native_holder_ptr')}(info);
            if (csharpMethodInfo->NeedBoxing)
            {
                auto ptrType = (Il2CppClass*) ${invokePapi('get_native_holder_typeid')}(info);
                if (Class::IsValuetype(ptrType))
                {
                    self = Object::Box(ptrType, self);
                }
            }
        }
        WrapData** wrapDatas = csharpMethodInfo->OverloadDatas.data();
        bool checkArgument = *wrapDatas && *(wrapDatas + 1);
        while(*wrapDatas)
        {
            if ((*wrapDatas)->Wrap(apis, (*wrapDatas)->Method, (*wrapDatas)->MethodPointer, info, env, self, checkArgument, *wrapDatas))
            {
                return;
            }
            ++wrapDatas;
        }
        std::string err_info = "invalid arguments to " + csharpMethodInfo->Name;
        ${invokePapi('throw_by_string')}(info, err_info.c_str()); 
    } 
    catch (Il2CppExceptionWrapper& exception)
    {
        Il2CppClass* klass = il2cpp::vm::Object::GetClass(exception.ex);
        const MethodInfo* toStringMethod = il2cpp::vm::Class::GetMethodFromName(klass, "ToString", 0);

        Il2CppException* outException = NULL;
        Il2CppString* result = (Il2CppString*)il2cpp::vm::Runtime::Invoke(toStringMethod, exception.ex, NULL, &outException);
        if (outException != NULL)
        {
            std::string err_info = "unknow c# execption for " + csharpMethodInfo->Name;
            ${invokePapi('throw_by_string')}(info, err_info.c_str());
        }
        else
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(result);
            std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
            ${invokePapi('throw_by_string')}(info, str.c_str());
        }
    }
}

static void GetterCallback(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    FieldWrapData* wrapData = static_cast<FieldWrapData*>(${invokePapi('get_userdata')}(info));
    wrapData->Getter(apis, info, wrapData->FieldInfo, wrapData->Offset, wrapData->TypeInfo);
}

static void SetterCallback(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    FieldWrapData* wrapData = static_cast<FieldWrapData*>(${invokePapi('get_userdata')}(info));
    wrapData->Setter(apis, info, wrapData->FieldInfo, wrapData->Offset, wrapData->TypeInfo);
}

void GetFieldValue(void *ptr, FieldInfo *field, size_t offset, void *value)
{
    void *src;

    if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(ptr);
        src = (char*)ptr + offset;
        Field::SetValueRaw(field->type, value, src, true);
    }
    else
    {
        il2cpp::vm::Runtime::ClassInit(field->parent);
        Field::StaticGetValue(field, value);
    }
}

void* GetValueTypeFieldPtr(void *obj, FieldInfo *field, size_t offset)
{
    if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(obj);
        return (char*)obj + offset;
    }
    else
    {
        Class::SetupFields(field->parent);

        void* threadStaticData = NULL;
        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
#ifdef UNITY_2021_1_OR_NEWER
            threadStaticData = Thread::GetThreadStaticDataForThread(field->parent->thread_static_fields_offset, il2cpp::vm::Thread::CurrentInternal());
#else
            threadStaticData = Thread::GetThreadStaticDataForThread(field->parent->thread_static_fields_offset, il2cpp::vm::Thread::Current());
#endif
        
        if (field->offset == THREAD_STATIC_FIELD_OFFSET)
        {
            IL2CPP_ASSERT(NULL != threadStaticData);
            int threadStaticFieldOffset = MetadataCache::GetThreadLocalStaticOffsetForField(field);
            return ((char*)threadStaticData) + threadStaticFieldOffset;
        }
        else
        {
            return ((char*)field->parent->static_fields) + field->offset;
        }
    }
}

void SetFieldValue(void *ptr, FieldInfo *field, size_t offset, void *value)
{
    void *dest;

    if(!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        IL2CPP_ASSERT(ptr);
        dest = (char*)ptr + offset;
        Field::SetValueRaw(field->type, dest, value, true);
    }
    else
    {
        Field::StaticSetValue(field, value);
    }
}

void* GetDefaultValuePtr(const MethodInfo* method, uint32_t index)
{
    bool isExplicitySetNullDefaultValue = false;
#ifdef UNITY_2021_1_OR_NEWER
    Il2CppObject* defaultValue = Parameter::GetDefaultParameterValueObject(method, index, &isExplicitySetNullDefaultValue);
#else
    Il2CppObject* defaultValue = Parameter::GetDefaultParameterValueObject(method, &method->parameters[index], &isExplicitySetNullDefaultValue);
#endif
    return (defaultValue && Class::IsValuetype(Class::FromIl2CppType(Method::GetParam(method, index), false))) ? Object::Unbox(defaultValue) : defaultValue;
}

typedef void(*LogCallbackFunc)(const char* value);

static LogCallbackFunc GLogCallback = nullptr;

void PLog(const char* Fmt, ...)
{
    static char SLogBuffer[1024];
    va_list list;
    va_start(list, Fmt);
    vsnprintf(SLogBuffer, sizeof(SLogBuffer), Fmt, list);
    va_end(list);

    if (GLogCallback)
    {
        GLogCallback(SLogBuffer);
    }
}

static void* CtorCallback(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    JsClassInfo* classInfo = reinterpret_cast<JsClassInfo*>(${invokePapi('get_userdata')}(info));
    // or will crash in macos.
    if (!classInfo->IsValueType && *(classInfo->CtorWrapDatas) == nullptr)
    {
        ${invokePapi('throw_by_string')}(info, "no valid constructor is found");
        return nullptr;
    }
    
    void* self = ObjectAllocate(classInfo->TypeId);

    auto isValueType = classInfo->IsValueType;
    
    try
    {
        WrapData** wrapDatas = classInfo->CtorWrapDatas;
        bool checkArgument = *wrapDatas && *(wrapDatas + 1);
        pesapi_env env = ${invokePapi('get_env')}(info);
        while(*wrapDatas)
        {
            if ((*wrapDatas)->Wrap(apis, (*wrapDatas)->Method, (*wrapDatas)->MethodPointer, info, env, self, checkArgument, *wrapDatas))
            {
                return self;
            }
            ++wrapDatas;
        }
        

        if (isValueType && ${invokePapi('get_args_len')}(info) == 0)
            return self;
        else
        {
            std::string err_info = "invalid arguments for constructor of " + classInfo->Name;
            ${invokePapi('throw_by_string')}(info, err_info.c_str());
        }
        
    } 
    catch (Il2CppExceptionWrapper& exception)
    {
        Il2CppClass* klass = il2cpp::vm::Object::GetClass(exception.ex);
        const MethodInfo* toStringMethod = il2cpp::vm::Class::GetMethodFromName(klass, "ToString", 0);

        Il2CppException* outException = NULL;
        Il2CppString* result = (Il2CppString*)il2cpp::vm::Runtime::Invoke(toStringMethod, exception.ex, NULL, &outException);
        if (outException != NULL)
        {
            std::string err_info = "unknow c# execption for constructor of " + classInfo->Name;
            ${invokePapi('throw_by_string')}(info, err_info.c_str());
        }
        else
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(result);
            std::string str = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
            ${invokePapi('throw_by_string')}(info, str.c_str());
        }
    }
    
    if (isValueType)
    {
        ValueTypeFree(self);
    }
    
    return nullptr;
}

static void SetPObjectRefInfoValue(struct pesapi_ffi* apis, pesapi_env env, PObjectRefInfo* objectInfo, pesapi_value_ref value_ref)
{
    objectInfo->Apis = apis;
    objectInfo->ValueRef = value_ref;
    objectInfo->EnvPrivate = (void*)${invokePapi('get_env_private')}(env);
}


static pesapi_value GetPObjectRefInfoValue(struct pesapi_ffi* apis, pesapi_env env, const PObjectRefInfo* objectInfo)
{    
    return ${invokePapi('get_value_from_ref')}(env, objectInfo->ValueRef);
}

#ifndef UNITY_6000_0_OR_NEWER
typedef int32_t Il2CppGCHandle;
#endif

constexpr size_t internal_field_count_for_gc_handle = (sizeof(Il2CppGCHandle) + sizeof(void*) - 1) / sizeof(void*);

static Il2CppGCHandle* FindOrCreateHandleStoreOfValue(struct pesapi_ffi* apis, pesapi_env env, pesapi_value value, pesapi_value_ref* out_value_ref, Il2CppObject** out_object)
{
    void* out_ptr;
    ${invokePapi('get_private')}(env, value, &out_ptr);
    
    pesapi_value_ref value_ref = static_cast<pesapi_value_ref>(out_ptr);
    Il2CppGCHandle* res = nullptr;
    uint32_t field_count;
    if (value_ref)
    {
        res = reinterpret_cast<Il2CppGCHandle*>(${invokePapi('get_ref_internal_fields')}(value_ref, &field_count));
        if(field_count != internal_field_count_for_gc_handle || !res)
        {
            PLog("invalid internal_fields size: %u, ptr:%p", field_count, res);
            ${invokePapi('release_value_ref')}(value_ref);
            res = nullptr;
            value_ref = nullptr;
        }
    }
    
    if (!res)
    {
        value_ref = ${invokePapi('create_value_ref')}(env, value, internal_field_count_for_gc_handle);
        
        *out_object = nullptr;
        if (${invokePapi('set_private')}(env, value, value_ref))
        {
            res = reinterpret_cast<Il2CppGCHandle*>(${invokePapi('get_ref_internal_fields')}(value_ref, &field_count));
        } // else etc. S_CLASS_MODULE_NS
    }
    else
    {
        *out_object = il2cpp::gc::GCHandle::GetTarget(*res);
        //PLog("found existed jsobject:%p", *out_object);
        if (out_object == nullptr)
        {
            value_ref = ${invokePapi('duplicate_value_ref')}(value_ref);
        }
    }
    
    *out_value_ref = value_ref;
    return res;
}

static Il2CppObject* FunctionToDelegate(struct pesapi_ffi* apis, pesapi_env env, pesapi_value jsval, JsClassInfoHeader* classInfo)
{
    pesapi_value_ref value_ref;
    Il2CppObject* ret = nullptr;
    Il2CppGCHandle* handle_store = FindOrCreateHandleStoreOfValue(apis, env, jsval, &value_ref, &ret);
    if (!handle_store) return nullptr;

    if (ret == nullptr)
    {
        PObjectRefInfo* delegateInfo;
        ret = (Il2CppObject *)DelegateAllocate(classInfo->TypeId, classInfo->DelegateBridge, &delegateInfo);
        auto targetHandle = il2cpp::gc::GCHandle::GetTargetHandle(ret, 0, il2cpp::gc::HANDLE_WEAK);
        il2cpp::vm::Exception::RaiseIfError(targetHandle.GetError());
        *handle_store = targetHandle.Get();
        SetPObjectRefInfoValue(apis, env, delegateInfo, value_ref);
    }
    return ret;
}

static void* DelegateCtorCallback(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    pesapi_env env = ${invokePapi('get_env')}(info);
    pesapi_value jsval = ${invokePapi('get_arg')}(info, 0);
    if (!${invokePapi('is_function')}(env, jsval))
    {
        ${invokePapi('throw_by_string')}(info, "expect a function");
        return nullptr;
    }
    JsClassInfoHeader* classInfo = reinterpret_cast<JsClassInfoHeader*>(${invokePapi('get_userdata')}(info));
    
    return FunctionToDelegate(apis, env, jsval, classInfo);
}

pesapi_value TryTranslateBuiltin(struct pesapi_ffi* apis, pesapi_env env, Il2CppObject* obj)
{
    if (obj)
    {
        if (obj->klass == g_typeofPersistentObjectInfo)
        {
            PObjectRefInfo* objectInfo = GetPObjectRefInfo(obj);
            return GetPObjectRefInfoValue(apis, env, objectInfo);
        }
        if (obj->klass == g_typeofArrayBuffer)
        {
            int32_t length = 0;
            il2cpp_field_get_value(obj, g_arrayBufferCountField, &length);

            Il2CppArray* buffer;
            il2cpp_field_get_value(obj, g_arrayBufferBytesField, &buffer);

            return ${invokePapi('create_binary')}(env, Array::GetFirstElementAddress(buffer), (size_t)length);
        }
    }
    return nullptr;
}

static pesapi_value TryTranslatePrimitivePtr(struct pesapi_ffi* apis, pesapi_env env, Il2CppTypeEnum type, void* ptr)
{
    switch (type)
    {
        case IL2CPP_TYPE_I1:
        {
            return ${invokePapi('create_int32')}(env, (int32_t)(*((int8_t*)ptr)));
        }
        case IL2CPP_TYPE_BOOLEAN:
        {
            return ${invokePapi('create_boolean')}(env, (bool)(*((uint8_t*)ptr)));
        }
        case IL2CPP_TYPE_U1:
        {
            return ${invokePapi('create_uint32')}(env, (uint32_t)(*((uint8_t*)ptr)));
        }
        case IL2CPP_TYPE_I2:
        {
            return ${invokePapi('create_int32')}(env, (int32_t)(*((int16_t*)ptr)));
        }
        case IL2CPP_TYPE_U2:
        {
            return ${invokePapi('create_uint32')}(env, (uint32_t)(*((uint16_t*)ptr)));
        }
        case IL2CPP_TYPE_CHAR:
        {
            return ${invokePapi('create_int32')}(env, (int32_t)(*((Il2CppChar*)ptr)));
        }
    #if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_I:
    #endif
        case IL2CPP_TYPE_I4:
        {
            return ${invokePapi('create_int32')}(env, (int32_t)(*((int32_t*)ptr)));
        }
    #if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_U:
    #endif
        case IL2CPP_TYPE_U4:
        {
            return ${invokePapi('create_uint32')}(env, (uint32_t)(*((uint32_t*)ptr)));
        }
    #if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_I:
    #endif
        case IL2CPP_TYPE_I8:
        {
            return ${invokePapi('create_int64')}(env, *((int64_t*)ptr));
        }
    #if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_U:
    #endif
        case IL2CPP_TYPE_U8:
        {
            return ${invokePapi('create_uint64')}(env, *((uint64_t*)ptr));
        }
        case IL2CPP_TYPE_R4:
        {
            return ${invokePapi('create_double')}(env, (double)(*((float*)ptr)));
        }
        case IL2CPP_TYPE_R8:
        {
            return ${invokePapi('create_double')}(env, *((double*)ptr));
        }

        default:
            return nullptr;
    }
}

static pesapi_value TryTranslatePrimitiveWithClass(struct pesapi_ffi* apis, pesapi_env env, Il2CppObject* obj, Il2CppClass *klass = nullptr)
{
    if (obj)
    {
        const Il2CppType *type = Class::GetType(klass ? klass : obj->klass);
        if (type->type == IL2CPP_TYPE_STRING)
        {
            const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars((Il2CppString*)obj);
            int32_t utf16len = il2cpp::utils::StringUtils::GetLength((Il2CppString*)obj);
            return ${invokePapi('create_string_utf16')}(env, reinterpret_cast<const uint16_t *>(utf16), utf16len);
        }
        void* ptr = Object::Unbox(obj);
        return TryTranslatePrimitivePtr(apis, env, type->type, ptr);
    }
    
    return nullptr;
}

pesapi_value TranslateValueType(struct pesapi_ffi* apis, pesapi_env env, Il2CppClass* targetClass, Il2CppObject* obj)
{
    auto len = targetClass->native_size;
    if (len < 0)
    {
        len = targetClass->instance_size - sizeof(Il2CppObject);
    }

    auto buff = new uint8_t[len];
    memcpy(buff, Object::Unbox(obj), len);
    return ${invokePapi('native_object_to_value')}(env, targetClass, buff, true);
}

pesapi_value TryTranslateValueType(struct pesapi_ffi* apis, pesapi_env env, Il2CppObject* obj)
{
    if (obj && obj->klass)
    {
        auto objClass = obj->klass;
        if (Class::IsValuetype(objClass))
        {
            return TranslateValueType(apis, env, objClass, obj);
        }
    }
    return nullptr;
}

union PrimitiveValueType
{
    int8_t i1;
    uint8_t u1;
    int16_t i2;
    uint16_t u2;
    int32_t i4;
    uint32_t u4;
    int64_t i8;
    uint64_t u8;
    Il2CppChar c;
    float r4;
    double r8;
};

Il2CppObject* JsValueToCSRef(struct pesapi_ffi* apis, Il2CppClass *klass, pesapi_env env, pesapi_value jsval)
{
    if (klass == il2cpp_defaults.void_class) return nullptr;
    
    if (!klass)
    {
        klass = il2cpp_defaults.object_class;
    }        
    
    const Il2CppType *type = Class::GetType(klass);
    int t = type->type;
    
    PrimitiveValueType data;
    
    void* toBox = &data;
    
    Il2CppObject* ret = nullptr;
    
handle_underlying:
    switch (t)
    {
        case IL2CPP_TYPE_I1:
        {
            data.i1 = (int8_t)${invokePapi('get_value_int32')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_BOOLEAN:
        {
            data.u1 = (uint8_t)${invokePapi('get_value_bool')}(env, jsval);
        }
        case IL2CPP_TYPE_U1:
        {
            data.u1 = (uint8_t)${invokePapi('get_value_uint32')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_I2:
        {
            data.i2 = (int16_t)${invokePapi('get_value_int32')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_U2:
        {
            data.u2 = (uint16_t)${invokePapi('get_value_uint32')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_CHAR:
        {
            data.c = (Il2CppChar)${invokePapi('get_value_uint32')}(env, jsval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_I:
#endif
        case IL2CPP_TYPE_I4:
        {
            data.i4 = (int32_t)${invokePapi('get_value_int32')}(env, jsval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 4
        case IL2CPP_TYPE_U:
#endif
        case IL2CPP_TYPE_U4:
        {
            data.u4 = (uint32_t)${invokePapi('get_value_uint32')}(env, jsval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_I:
#endif
        case IL2CPP_TYPE_I8:
        {
            data.i8 = ${invokePapi('get_value_int64')}(env, jsval);
            break;
        }
#if IL2CPP_SIZEOF_VOID_P == 8
        case IL2CPP_TYPE_U:
#endif
        case IL2CPP_TYPE_U8:
        {
            data.u8 = ${invokePapi('get_value_uint64')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_R4:
        {
            data.r4 = (float)${invokePapi('get_value_double')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_R8:
        {
            data.r8 = ${invokePapi('get_value_double')}(env, jsval);
            break;
        }
        case IL2CPP_TYPE_STRING:
        {
            size_t bufsize = 0;
            auto str = ${invokePapi('get_value_string_utf16')}(env, jsval, nullptr, &bufsize);
            if (str)
            {
                return (Il2CppObject*)il2cpp::vm::String::NewUtf16(reinterpret_cast<const Il2CppChar *>(str), bufsize);
            }
            std::vector<uint16_t> buff;
            buff.resize(bufsize + 1);
            str = ${invokePapi('get_value_string_utf16')}(env, jsval, buff.data(), &bufsize);
            if (str)
            {
                buff[bufsize] = '\0';
                return (Il2CppObject*)il2cpp::vm::String::NewUtf16(reinterpret_cast<const Il2CppChar *>(str), bufsize);
            }
            return nullptr;
        }
        case IL2CPP_TYPE_SZARRAY:
        case IL2CPP_TYPE_CLASS:
        case IL2CPP_TYPE_OBJECT:
        case IL2CPP_TYPE_ARRAY:
        case IL2CPP_TYPE_FNPTR:
        case IL2CPP_TYPE_PTR:
        {
            if (${invokePapi('is_function')}(env, jsval))
            {
                if (IsDelegate(klass))
                {
                    JsClassInfoHeader* jsClassInfo = (JsClassInfoHeader*)pesapi_get_class_data(klass, true);
                    if (!jsClassInfo)
                    {
                        Exception::Raise(Exception::GetInvalidOperationException("call not load type of delegate"));
                    }
                    return FunctionToDelegate(apis, env, jsval, jsClassInfo);
                }
            }
            auto ptr = ${invokePapi('get_native_object_ptr')}(env, jsval);
            if (!ptr)
            {
                if ((klass == g_typeofArrayBuffer || klass == il2cpp_defaults.object_class) && ${invokePapi('is_binary')}(env, jsval)) 
                {
                    Il2CppObject* ret = il2cpp::vm::Object::New(g_typeofArrayBuffer);

                    const MethodInfo* ctor = il2cpp_class_get_method_from_name(g_typeofArrayBuffer, ".ctor", 3);
                    typedef void (*NativeCtorPtr)(Il2CppObject* ___this, void*, int, int, const MethodInfo* method);
                    
                    void* data;
                    size_t length;
                    data = ${invokePapi('get_value_binary')}(env, jsval, &length);
                    ((NativeCtorPtr)ctor->methodPointer)(ret, data, (int)length, 0, ctor);   
                    return ret;
                }
                if ((klass == g_typeofPersistentObjectInfo || klass == il2cpp_defaults.object_class) && ${invokePapi('is_object')}(env, jsval))
                {
                    Il2CppClass* persistentObjectInfoClass = g_typeofPersistentObjectInfo;
                    
                    pesapi_value_ref value_ref;
                    Il2CppObject* ret = nullptr;
                    Il2CppGCHandle* handle_store = FindOrCreateHandleStoreOfValue(apis, env, jsval, &value_ref, &ret);
                    
                    if (ret == nullptr) 
                    {
                        ret = il2cpp::vm::Object::New(persistentObjectInfoClass);
                        

                        const MethodInfo* ctor = il2cpp_class_get_method_from_name(persistentObjectInfoClass, ".ctor", 0);
                        typedef void (*NativeCtorPtr)(Il2CppObject* ___this, const MethodInfo* method);
                        ((NativeCtorPtr)ctor->methodPointer)(ret, ctor);
                        
                        PObjectRefInfo* objectInfo = GetPObjectRefInfo(ret);
                        if (handle_store)
                        {
                            auto targetHandle = il2cpp::gc::GCHandle::GetTargetHandle(ret, 0, il2cpp::gc::HANDLE_WEAK);
                            il2cpp::vm::Exception::RaiseIfError(targetHandle.GetError());
                            *handle_store = targetHandle.Get();
                        }
                        SetPObjectRefInfoValue(apis, env, objectInfo, value_ref);
                    }
                    return ret;
                }
                if (klass == il2cpp_defaults.object_class)
                {
                    if (${invokePapi('is_string')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_STRING;
                        klass = il2cpp_defaults.string_class;
                    }
                    else if (${invokePapi('is_double')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_R8;
                        klass = il2cpp_defaults.double_class;
                    }
                    else if (${invokePapi('is_int32')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_I4;
                        klass = il2cpp_defaults.int32_class;
                    }
                    else if (${invokePapi('is_uint32')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_U4;
                        klass = il2cpp_defaults.uint32_class;
                    }
                    else if (${invokePapi('is_int64')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_I8;
                        klass = il2cpp_defaults.int64_class;
                    }
                    else if (${invokePapi('is_uint64')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_U8;
                        klass = il2cpp_defaults.uint64_class;
                    }
                    else if (${invokePapi('is_boolean')}(env, jsval))
                    {
                        t = IL2CPP_TYPE_BOOLEAN;
                        klass = il2cpp_defaults.boolean_class;
                    }
                    else
                    {
                        goto return_nothing;
                    }
                    goto handle_underlying;
                }
            return_nothing:
                return nullptr;
            }
            auto objClass = (Il2CppClass *)${invokePapi('get_native_object_typeid')}(env, jsval);
            if (klass == il2cpp_defaults.object_class && g_typeofTypedValue && Class::IsAssignableFrom(g_typeofTypedValue, objClass))
            {
                const MethodInfo* get_Target = il2cpp_class_get_method_from_name(objClass, "get_Target", 0);
                if (get_Target)
                {
                    typedef Il2CppObject* (*NativeFuncPtr)(void* ___this, const MethodInfo* method);
                    return ((NativeFuncPtr)get_Target->methodPointer)(ptr, get_Target);
                }
            }
            if (Class::IsAssignableFrom(klass, objClass))
            {
                return Class::IsValuetype(objClass) ? Object::Box(objClass, ptr) : (Il2CppObject*)ptr;
            }
            return nullptr;
        }
        case IL2CPP_TYPE_VALUETYPE:
            /* note that 't' and 'type->type' can be different */
            if (type->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(type))
            {
                t = Class::GetEnumBaseType(Type::GetClass(type))->type;
                goto handle_underlying;
            }
            else
            {
                auto objClass = (Il2CppClass *)${invokePapi('get_native_object_typeid')}(env, jsval);
                if (!Class::IsAssignableFrom(klass, objClass))
                {
                    return nullptr;
                }
                toBox = ${invokePapi('get_native_object_ptr')}(env, jsval);
                if (!toBox)
                {
                    std::string message = "expect ValueType: ";
                    message += klass->name;
                    message += ", by got null";
                    Exception::Raise(Exception::GetInvalidOperationException(message.c_str()));
                    return nullptr;
                }
            }
            break;
        case IL2CPP_TYPE_GENERICINST:
            t = GenericClass::GetTypeDefinition(type->data.generic_class)->byval_arg.type;
            goto handle_underlying;
        default:
            IL2CPP_ASSERT(0);
    }
    return Object::Box(klass, toBox);
}

pesapi_value CSRefToJsValue(struct pesapi_ffi* apis, pesapi_env env, Il2CppClass *targetClass, Il2CppObject* obj)
{
    if (targetClass == il2cpp_defaults.void_class ) return ${invokePapi('create_undefined')}(env);
    if (!obj) return ${invokePapi('create_null')}(env);

    if (!targetClass)
    {
        targetClass = il2cpp_defaults.object_class;
    }
    
    if (Class::IsEnum(targetClass))
    {
        targetClass = Class::GetElementClass(targetClass);
    }
    
    pesapi_value jsVal = TryTranslatePrimitiveWithClass(apis, env, obj, targetClass != il2cpp_defaults.object_class ? targetClass : nullptr);
    
    if (jsVal) 
    {
        return jsVal;
    }

    if (Class::IsValuetype(targetClass))
    {
        jsVal = TranslateValueType(apis, env, targetClass, obj);
        if (jsVal)
        {
            return jsVal;
        }    
    }
    
    jsVal = TryTranslateValueType(apis, env, obj);
    if (jsVal) 
    {
        return jsVal;
    }

    jsVal = TryTranslateBuiltin(apis, env, obj);

    if (jsVal)
    {
        return jsVal;
    }

    auto objClass = obj && obj->klass ? obj->klass : targetClass;
    return ${invokePapi('native_object_to_value')}(env, objClass, obj, false);
}

static bool NullableHasValue(Il2CppClass* klass, void* data)
{
    uint8_t* hasValueByte = static_cast<uint8_t*>(data);
    return *hasValueByte != 0;
}

pesapi_value CSValueTypePtrToJsValue(struct pesapi_ffi* apis, pesapi_env env, Il2CppClass* targetClass, void* ptr)
{
    if (targetClass == il2cpp_defaults.void_class) return ${invokePapi('create_undefined')}(env);
    if (!ptr) return ${invokePapi('create_null')}(env);

    if (!targetClass)
    {
        targetClass = il2cpp_defaults.object_class;
    }

    bool isNullable = Class::IsNullable(targetClass);

    if (isNullable)
    {
        if (!NullableHasValue(targetClass, ptr))
        {
            return ${invokePapi('create_null')}(env);
        }
        uint8_t* valueStart = static_cast<uint8_t*>(ptr);
        int32_t nullableShift = targetClass->fields[1].offset - sizeof(Il2CppObject);
        valueStart += nullableShift;
        ptr = valueStart;
    }

    if (Class::IsEnum(targetClass))
    {
        targetClass = Class::GetElementClass(targetClass);
    }
    const Il2CppType* type = Class::GetType(targetClass);

    pesapi_value jsVal = TryTranslatePrimitivePtr(apis, env, type->type, ptr);

    if (jsVal)
    {
        return jsVal;
    }

    auto len = targetClass->native_size;
    if (len < 0)
    {
        len = targetClass->instance_size - sizeof(Il2CppObject);
    }

    auto buff = new uint8_t[len];
    memcpy(buff, ptr, len);
    return ${invokePapi('native_object_to_value')}(env, targetClass, buff, true);
}

static bool GetValueTypeFromJs(struct pesapi_ffi* apis, pesapi_env env, pesapi_value jsValue, Il2CppClass* klass, void* storage)
{
    bool hasValue = false;
    uint32_t valueSize = klass->instance_size - sizeof(Il2CppObject);
    if (!jsValue) return false;
    void* ptr;
    if (${invokePapi('is_object')}(env, jsValue) && (ptr = ${invokePapi('get_native_object_ptr')}(env, jsValue)))
    {
        auto objClass = (Il2CppClass*) ${invokePapi('get_native_object_typeid')}(env, jsValue);
        if (Class::IsAssignableFrom(klass, objClass))
        {
            hasValue = true;
            memcpy(storage, ptr, valueSize);
        }

    } else {
        const Il2CppType *type = Class::GetType(klass);
        PrimitiveValueType data;
        data.i8 = 0;
        int t = type->type;
handle_underlying:
        switch (t)
        {
            case IL2CPP_TYPE_I1:
            {
                if (${invokePapi('is_int32')}(env, jsValue))
                {
                    data.i1 = (int8_t)${invokePapi('get_value_int32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_BOOLEAN:
            {
                if (${invokePapi('is_boolean')}(env, jsValue))
                {
                    data.u1 = (uint8_t)${invokePapi('get_value_bool')}(env, jsValue);
                    hasValue = true;
                }
            }
            case IL2CPP_TYPE_U1:
            {
                if (${invokePapi('is_uint32')}(env, jsValue))
                {
                    data.u1 = (uint8_t)${invokePapi('get_value_uint32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_I2:
            {
                if (${invokePapi('is_int32')}(env, jsValue))
                {
                    data.i2 = (int16_t)${invokePapi('get_value_int32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_U2:
            {
                if (${invokePapi('is_uint32')}(env, jsValue))
                {
                    data.u2 = (uint16_t)${invokePapi('get_value_uint32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_CHAR:
            {
                if (${invokePapi('is_uint32')}(env, jsValue))
                {
                    data.c = (Il2CppChar)${invokePapi('get_value_uint32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_I:
    #endif
            case IL2CPP_TYPE_I4:
            {
                if (${invokePapi('is_int32')}(env, jsValue))
                {
                    data.i4 = (int32_t)${invokePapi('get_value_int32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 4
            case IL2CPP_TYPE_U:
    #endif
            case IL2CPP_TYPE_U4:
            {
                if (${invokePapi('is_uint32')}(env, jsValue))
                {
                    data.u4 = (uint32_t)${invokePapi('get_value_uint32')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_I:
    #endif
            case IL2CPP_TYPE_I8:
            {
                if (${invokePapi('is_int64')}(env, jsValue))
                {
                    data.i8 = ${invokePapi('get_value_int64')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }   
    #if IL2CPP_SIZEOF_VOID_P == 8
            case IL2CPP_TYPE_U:
    #endif
            case IL2CPP_TYPE_U8:
            {
                if (${invokePapi('is_uint64')}(env, jsValue))
                {
                    data.u8 = ${invokePapi('get_value_uint64')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_R4:
            {
                if (${invokePapi('is_double')}(env, jsValue))
                {
                    data.r4 = (float)${invokePapi('get_value_double')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_R8:
            {
                if (${invokePapi('is_double')}(env, jsValue))
                {
                    data.r8 = ${invokePapi('get_value_double')}(env, jsValue);
                    hasValue = true;
                }
                break;
            }
            case IL2CPP_TYPE_VALUETYPE:
            /* note that 't' and 'type->type' can be different */
            if (type->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(type))
            {
                t = Class::GetEnumBaseType(Type::GetClass(type))->type;
                goto handle_underlying;
            }
        }
    
        if(hasValue)
        {
            memcpy(storage, &data, valueSize);
        }
    }
    return hasValue;
}

static pesapi_value JsObjectUnRef(struct pesapi_ffi* apis, pesapi_env env, pesapi_value jsValue)
{
    return (${invokePapi('is_object')}(env, jsValue)) ?  ${invokePapi('get_property_uint32')}(env, jsValue, 0) : nullptr;
}

static void JsObjectSetRef(struct pesapi_ffi* apis, pesapi_env env, pesapi_value outer, pesapi_value val)
{
    if (outer && val && ${invokePapi('is_object')}(env, outer))
    {
        ${invokePapi('set_property_uint32')}(env, outer, 0, val);
    }
}

static bool ReflectionWrapper(struct pesapi_ffi* apis, MethodInfo* method, Il2CppMethodPointer methodPointer, pesapi_callback_info info, pesapi_env env, void* self, bool checkJSArgument, WrapData* wrapData)
{
    int js_args_len = ${invokePapi('get_args_len')}(info);
    bool hasParamArray = wrapData->HasParamArray;
    bool isExtensionMethod = wrapData->IsExtensionMethod;
    auto csArgStart = isExtensionMethod ? 1 : 0;
    
    if (checkJSArgument || wrapData->OptionalNum > 0)
    {
        if (!hasParamArray && wrapData->OptionalNum == 0)
        {
            if (js_args_len != method->parameters_count - csArgStart)
            {
                return false;
            }
        }
        else
        {
            auto requireNum = method->parameters_count - csArgStart - wrapData->OptionalNum - (hasParamArray ? 1 : 0);
            if (js_args_len < requireNum)
            {
                return false;
            }
        }
        for (int i = csArgStart; i < method->parameters_count; ++i)
        {
            auto parameterType = Method::GetParam(method, i);
            bool passedByReference = parameterType->byref;
            bool hasDefault = parameterType->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT;
            bool isLastArgument = i == (method->parameters_count - 1);
            Il2CppClass* parameterKlass = Class::FromIl2CppType(parameterType);
            Class::Init(parameterKlass);
            pesapi_value jsValue = ${invokePapi('get_arg')}(info, i - csArgStart);
            
            if ((hasDefault || (isLastArgument && hasParamArray)) && ${invokePapi('is_undefined')}(env, jsValue))
            {
                continue;
            }
            if (passedByReference)
            {
                if (${invokePapi('is_object')}(env, jsValue))
                {
                    continue;
                }
                else
                {
                    return false;
                }
            }
            int t;
            if (isLastArgument && hasParamArray)
                t = (int) parameterKlass->element_class->byval_arg.type;
            else
                t = parameterType->type; 
handle_underlying:
            switch (t)
            {
                case IL2CPP_TYPE_I1:
                case IL2CPP_TYPE_I2:
#if IL2CPP_SIZEOF_VOID_P == 4
                case IL2CPP_TYPE_I:
#endif
                case IL2CPP_TYPE_I4:
                {
                    if (!${invokePapi('is_int32')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_BOOLEAN:
                {
                    if (!${invokePapi('is_boolean')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_U1:
                case IL2CPP_TYPE_U2:
                case IL2CPP_TYPE_CHAR:
#if IL2CPP_SIZEOF_VOID_P == 4
                case IL2CPP_TYPE_U:
#endif
                case IL2CPP_TYPE_U4:
                {
                    if (!${invokePapi('is_uint32')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
        #if IL2CPP_SIZEOF_VOID_P == 8
                case IL2CPP_TYPE_I:
        #endif
                case IL2CPP_TYPE_I8:
                {
                    if (!${invokePapi('is_int64')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
        #if IL2CPP_SIZEOF_VOID_P == 8
                case IL2CPP_TYPE_U:
        #endif
                case IL2CPP_TYPE_U8:
                {
                    if (!${invokePapi('is_uint64')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_R4:
                case IL2CPP_TYPE_R8:
                {
                    if (!${invokePapi('is_double')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_STRING:
                {
                    if (!${invokePapi('is_string')}(env, jsValue) && !${invokePapi('is_null')}(env, jsValue) && !${invokePapi('is_undefined')}(env, jsValue))
                    {
                        return false;
                    }
                    break;
                }
                case IL2CPP_TYPE_SZARRAY:
                case IL2CPP_TYPE_CLASS:
                case IL2CPP_TYPE_OBJECT:
                case IL2CPP_TYPE_ARRAY:
                case IL2CPP_TYPE_FNPTR:
                case IL2CPP_TYPE_PTR:
                {
                    if (${invokePapi('is_function')}(env, jsValue) && DataTransfer::IsDelegate(parameterKlass))
                    {
                        continue;
                    }
                    if (parameterKlass == il2cpp_defaults.object_class)
                    {
                        continue;
                    }
                    auto ptr = ${invokePapi('get_native_object_ptr')}(env, jsValue);
                    if (ptr)
                    {
                        auto objClass = (Il2CppClass *)${invokePapi('get_native_object_typeid')}(env, jsValue);
                        if (!Class::IsAssignableFrom(parameterKlass, objClass))
                        {
                            return false;
                        }
                    }
                    else if (!${invokePapi('is_null')}(env, jsValue) && !${invokePapi('is_undefined')}(env, jsValue))
                    {
                        return false;
                    }
                    //nullptr will match ref type
                    break;
                }
                case IL2CPP_TYPE_VALUETYPE:
                    /* note that 't' and 'type->type' can be different */
                    if (parameterType->type == IL2CPP_TYPE_VALUETYPE && Type::IsEnum(parameterType))
                    {
                        t = Class::GetEnumBaseType(Type::GetClass(parameterType))->type;
                        goto handle_underlying;
                    }
                    else
                    {
                        auto objClass = (Il2CppClass *)${invokePapi('get_native_object_typeid')}(env, jsValue);
                        if (!objClass || !Class::IsAssignableFrom(parameterKlass, objClass))
                        {
                            return false;
                        }
                    }
                    break;
                case IL2CPP_TYPE_GENERICINST:
                    t = GenericClass::GetTypeDefinition(parameterType->data.generic_class)->byval_arg.type;
                    goto handle_underlying;
                default:
                    IL2CPP_ASSERT(0);
            }
        }
    }
    void** args = method->parameters_count > 0 ? (void**)alloca(sizeof(void*) * method->parameters_count) : nullptr;
#ifndef UNITY_2021_1_OR_NEWER
    if (self)
    {
        Il2CppClass* thisType = method->klass;

        if (Class::IsValuetype(thisType))
        {
            self = ((uint8_t*)self) - sizeof(Il2CppObject);
        }
    }
#endif
    if (isExtensionMethod)
    {
        args[0] = ${invokePapi('get_native_holder_ptr')}(info);
    }
    
    for (int i = csArgStart; i < method->parameters_count; ++i) 
    {
        auto parameterType = Method::GetParam(method, i);
        bool passedByReference = parameterType->byref;
        bool hasDefault = parameterType->attrs & PARAM_ATTRIBUTE_HAS_DEFAULT;
        bool isLastArgument = i == (method->parameters_count - 1);
        Il2CppClass* parameterKlass = Class::FromIl2CppType(parameterType);
        Class::Init(parameterKlass);
        
        if (isLastArgument && hasParamArray)
        {
            int jsParamStart = i - csArgStart;
            auto elementType = Class::FromIl2CppType(&parameterKlass->element_class->byval_arg);
            auto arrayLen = js_args_len - jsParamStart > 0 ? js_args_len - jsParamStart : 0;
            auto array = Array::NewSpecific(parameterKlass, arrayLen);
            if (Class::IsValuetype(elementType))
            {
                auto valueSize = elementType->instance_size - sizeof(Il2CppObject);
                char* addr = Array::GetFirstElementAddress(array);
                for(int j = jsParamStart; j < js_args_len; ++j)
                {
                    GetValueTypeFromJs(apis, env, ${invokePapi('get_arg')}(info, j), elementType, addr + valueSize * (j - i + csArgStart));
                }
            }
            else
            {
                for(int j = jsParamStart; j < js_args_len; ++j)
                {
                    il2cpp_array_setref(array, j - i + csArgStart, JsValueToCSRef(apis, elementType, env, ${invokePapi('get_arg')}(info, j)));
                }
            }
            args[i] = array;
            continue;
        }
        
        pesapi_value jsValue = ${invokePapi('get_arg')}(info, i - csArgStart);
        
        if (Class::IsValuetype(parameterKlass))
        {
            if (Class::IsNullable(parameterKlass))
            {
                void* storage = alloca(parameterKlass->instance_size - sizeof(Il2CppObject));
                auto underlyClass = Class::GetNullableArgument(parameterKlass);
                uint32_t valueSize = underlyClass->instance_size - sizeof(Il2CppObject);
                bool hasValue = GetValueTypeFromJs(apis, env, jsValue, underlyClass, storage);
#ifndef UNITY_2021_1_OR_NEWER
                *(static_cast<uint8_t*>(storage) + valueSize) = hasValue;
#else
                *(static_cast<uint8_t*>(storage)) = hasValue;
#endif    // ! 

                args[i] = storage;
            }
            else if (passedByReference)
            {
                auto underlyClass = Class::FromIl2CppType(&parameterKlass->byval_arg);
                void* storage = alloca(underlyClass->instance_size - sizeof(Il2CppObject));
                jsValue = JsObjectUnRef(apis, env, jsValue);
                GetValueTypeFromJs(apis, env, jsValue, underlyClass, storage);
                args[i] = storage;
            }
            else if (hasDefault && ${invokePapi('is_undefined')}(env, jsValue))
            {
                void* storage = GetDefaultValuePtr(method, i);
                if (!storage)
                {
                    auto valueSize = parameterKlass->instance_size - sizeof(Il2CppObject);
                    storage = alloca(valueSize);
                    memset(storage, 0, valueSize);
                }
                args[i] = storage;
            }
            else
            {
                auto valueSize = parameterKlass->instance_size - sizeof(Il2CppObject);
                void* storage = alloca(valueSize);
                bool hasValue = GetValueTypeFromJs(apis, env, jsValue, parameterKlass, storage);
                if (!hasValue)
                {
                    memset(storage, 0, valueSize);
                }
                args[i] = storage;
            }
        }
        else if (passedByReference)
        {
            //convertedParameters[i] = &parameters[i]; // Reference type passed by reference
            void** arg = (void**)alloca(sizeof(void*));
            *arg = nullptr;
            auto underlyClass = Class::FromIl2CppType(&parameterKlass->byval_arg);
            jsValue = JsObjectUnRef(apis, env, jsValue);
            if (jsValue)
            {
                auto ptr = ${invokePapi('get_native_object_ptr')}(env, jsValue);
                if (ptr)
                {
                    auto objClass = (Il2CppClass *)${invokePapi('get_native_object_typeid')}(env, jsValue);
                    if (Class::IsAssignableFrom(underlyClass, objClass))
                    {
                        *arg = ptr;
                    }
                }
                else if (underlyClass == il2cpp_defaults.object_class) // any type
                {
                    *arg = JsValueToCSRef(apis, underlyClass, env, jsValue);
                }
            }
            args[i] = arg;
        }
        else if (parameterKlass->byval_arg.type == IL2CPP_TYPE_PTR)
        {
            auto underlyClass = Class::FromIl2CppType(&parameterKlass->element_class->byval_arg);
            void* storage = alloca(underlyClass->instance_size - sizeof(Il2CppObject));
            jsValue = JsObjectUnRef(apis, env, jsValue);
            args[i] = GetValueTypeFromJs(apis, env, jsValue, underlyClass, storage) ? storage : nullptr;
        }
        else
        {
            args[i] = (hasDefault && ${invokePapi('is_undefined')}(env, jsValue)) ? GetDefaultValuePtr(method, i): JsValueToCSRef(apis, parameterKlass, env, jsValue);
        }
    }
    
    //Il2CppObject* ret = Runtime::InvokeWithThrow(method, self, args); //返回ValueType有boxing
    void* returnValue = NULL;
    bool returnIsValueType = false;
    Il2CppClass* returnType = Class::FromIl2CppType(method->return_type);
    if (method->return_type->type == IL2CPP_TYPE_VOID)
    {
        method->invoker_method(method->methodPointer, method, self, args, NULL);
    }
    else
    {
        if (method->return_type->valuetype)
        {
            Class::Init(returnType);
            returnValue = alloca(returnType->instance_size - sizeof(Il2CppObject));
            method->invoker_method(method->methodPointer, method, self, args, returnValue);
            returnIsValueType = true;
        }
        else
        {
            method->invoker_method(method->methodPointer, method, self, args, &returnValue);
            if (method->return_type->byref)
            {
                if (Class::IsValuetype(returnType))
                {
                    returnIsValueType = true;
                }
                else
                {
                    returnValue = *(Il2CppObject**)returnValue;
                }
            }
        }
    }
    
    for (int i = csArgStart; i < method->parameters_count; ++i)
    {
        auto parameterType = Method::GetParam(method, i);
        bool passedByReference = parameterType->byref;
        Il2CppClass* parameterKlass = Class::FromIl2CppType(parameterType);
        
        pesapi_value jsValue = ${invokePapi('get_arg')}(info, i - csArgStart);
        
        if (Class::IsValuetype(parameterKlass) && passedByReference)
        {
            if (Class::IsNullable(parameterKlass))
            {
#ifndef UNITY_2021_1_OR_NEWER
                bool hasValue = !!*(static_cast<uint8_t*>(args[i]) + parameterKlass->instance_size - sizeof(Il2CppObject));
#else
                bool hasValue = !!*(static_cast<uint8_t*>(args[i]));
#endif    // ! 
                if (!hasValue)
                {
                    JsObjectSetRef(apis, env, jsValue, ${invokePapi('create_null')}(env));
                    continue;
                }
            }
            auto underlyClass = Class::FromIl2CppType(&parameterKlass->byval_arg);
            JsObjectSetRef(apis, env, jsValue, CSRefToJsValue(apis, env, underlyClass, (Il2CppObject*)(((uint8_t*)args[i]) - sizeof(Il2CppObject))));
        }
        else if (passedByReference)
        {
            Il2CppObject** arg = (Il2CppObject**)args[i];
            auto underlyClass = Class::FromIl2CppType(&parameterKlass->byval_arg);
            JsObjectSetRef(apis, env, jsValue, CSRefToJsValue(apis, env, underlyClass, *arg));
        }
        else if (parameterKlass->byval_arg.type == IL2CPP_TYPE_PTR)
        {
            auto underlyClass = Class::FromIl2CppType(&parameterKlass->element_class->byval_arg);
            JsObjectSetRef(apis, env, jsValue, CSRefToJsValue(apis, env, underlyClass, (Il2CppObject*)(((uint8_t*)args[i]) - sizeof(Il2CppObject))));
        }
    }
    
    if (method->return_type->type != IL2CPP_TYPE_VOID)
    {
        if (returnIsValueType)
        {
            ${invokePapi('add_return')}(info, CSValueTypePtrToJsValue(apis, env, returnType, returnValue));
        }
        else
        {
            ${invokePapi('add_return')}(info, CSRefToJsValue(apis, env, returnType, (Il2CppObject*)returnValue));
        }
    }
    
    return true;
}

static void ReflectionGetFieldWrapper(struct pesapi_ffi* apis, pesapi_callback_info info, FieldInfo* field, size_t offset, Il2CppClass* fieldType)
{
    pesapi_env env = ${invokePapi('get_env')}(info);
    void* csThis = nullptr;
    if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        csThis = ${invokePapi('get_native_holder_ptr')}(info);
    }
    
    if (Class::IsValuetype(fieldType))
    {
        void* storage = nullptr;
        bool isFieldPtr = true;
        auto expectType = fieldType;
        if (Class::IsNullable(fieldType))
        {
            expectType = Class::GetNullableArgument(fieldType);
        }
        if (Class::IsEnum(fieldType))
        {
            expectType = Class::GetElementClass(fieldType);
        }
        
        if ((field->type->attrs & FIELD_ATTRIBUTE_STATIC))
        {
            int t = Class::GetType(fieldType)->type;
            //il2cpp-blob.h
            if (t >= IL2CPP_TYPE_BOOLEAN && t <= IL2CPP_TYPE_R8 || t == IL2CPP_TYPE_I || t == IL2CPP_TYPE_U)
            {
                storage = alloca(expectType->instance_size - sizeof(Il2CppObject));
                GetFieldValue(csThis, field, offset, storage);
                isFieldPtr = false;
            }
            else
            {
                storage = GetValueTypeFieldPtr(csThis, field, offset);
            }
        }
        else if (csThis)
        {
            storage = (char*)csThis + offset;
        }
        if (!storage)
        {
            storage = alloca(expectType->instance_size - sizeof(Il2CppObject));
            GetFieldValue(csThis, field, offset, storage);
            isFieldPtr = false;
        }

        Il2CppObject* obj = (Il2CppObject*) storage - 1;
        pesapi_value jsVal = TryTranslatePrimitiveWithClass(apis, env, obj, expectType);
    
        if (!jsVal) 
        {
            if (isFieldPtr)
            {
                jsVal = ${invokePapi('native_object_to_value')}(env, expectType, storage, false);
            }
            else
            {
                auto valueSize = expectType->instance_size - sizeof(Il2CppObject);
                auto buff = new uint8_t[valueSize];
                memcpy(buff, storage, valueSize);
                jsVal = ${invokePapi('native_object_to_value')}(env, expectType, buff, true);
            }
        }
        
        if (jsVal)
        {
            ${invokePapi('add_return')}(info, jsVal);
        }
    }
    else
    {
        void* storage = nullptr;
        GetFieldValue(csThis, field, offset, &storage);
        ${invokePapi('add_return')}(info, CSRefToJsValue(apis, env, fieldType, (Il2CppObject*)storage));
    }
}

static void ReflectionSetFieldWrapper(struct pesapi_ffi* apis, pesapi_callback_info info, FieldInfo* field, size_t offset, Il2CppClass* fieldType)
{
    pesapi_env env = ${invokePapi('get_env')}(info);
    void* csThis = nullptr;
    if (!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
    {
        csThis = ${invokePapi('get_native_holder_ptr')}(info);
    }
    pesapi_value jsValue = ${invokePapi('get_arg')}(info, 0);
    if (Class::IsValuetype(fieldType))
    {
        if (Class::IsNullable(fieldType))
        {
            void* storage = alloca(fieldType->instance_size - sizeof(Il2CppObject));
            auto underlyClass = Class::GetNullableArgument(fieldType);
            uint32_t valueSize = underlyClass->instance_size - sizeof(Il2CppObject);
            bool hasValue = GetValueTypeFromJs(apis, env, jsValue, underlyClass, storage);
#ifndef UNITY_2021_1_OR_NEWER
            *(static_cast<uint8_t*>(storage) + valueSize) = hasValue;
#else
            *(static_cast<uint8_t*>(storage)) = hasValue;
#endif    // ! 
            SetFieldValue(csThis, field, offset, storage);
        }
        else
        {
            auto valueSize = fieldType->instance_size - sizeof(Il2CppObject);
            void* storage = alloca(valueSize);
            bool hasValue = GetValueTypeFromJs(apis, env, jsValue, fieldType, storage);
            if (!hasValue)
            {
                memset(storage, 0, valueSize);
            }
            SetFieldValue(csThis, field, offset, storage);
        }
    }
    else
    {
        void* val = JsValueToCSRef(apis, fieldType, env, jsValue);
        
        if(!(field->type->attrs & FIELD_ATTRIBUTE_STATIC))
        {
            SetFieldValue(csThis, field, offset, &val);
        }
        else
        {
            SetFieldValue(csThis, field, offset, val);
        }
    }
}

Il2CppObject* GetJSObjectValue(Il2CppObject* jsObject, struct pesapi_ffi* apis, Il2CppString* key, Il2CppReflectionType* rtype)
{
    PObjectRefInfo* objectInfo = GetPObjectRefInfo(jsObject);

    const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(key);
    std::string key_std = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);

    auto type = il2cpp_codegen_class_from_type(rtype->type);
    
    pesapi_env_ref envRef = ${invokePapi('get_ref_associated_env')}(objectInfo->ValueRef);
    AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    auto obj = ${invokePapi('get_value_from_ref')}(env, objectInfo->ValueRef);
    auto val = ${invokePapi('get_property')}(env, obj, key_std.c_str());
    if (!val)
    {
        return nullptr;
    }
    return JsValueToCSRef(apis, type, env, val);
}

Il2CppObject* EvalInternal(struct pesapi_ffi* apis, intptr_t ptr, Il2CppArray * __code, Il2CppString* __path, Il2CppReflectionType *__type)
{
    pesapi_env_ref envRef = reinterpret_cast<pesapi_env_ref>(ptr);
    
    AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    
    const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(__path);
    std::string path = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
    
    auto codeSize = il2cpp_array_length(__code);
    uint8_t* code = (uint8_t*)il2cpp_array_addr_with_size(__code, il2cpp_array_element_size(__code->klass), 0);
    
    auto ret = ${invokePapi('eval')}(env, code, codeSize, path.c_str());
    
    if (${invokePapi('has_caught')}(ValueScope.scope()))
    {
        Exception::Raise(Exception::GetInvalidOperationException(${invokePapi('get_exception_as_string')}(ValueScope.scope(), true)));
        return nullptr;
    }
    if (__type)
    {
        auto csRet = JsValueToCSRef(apis, il2cpp_codegen_class_from_type(__type->type), env, ret);
        if (${invokePapi('has_caught')}(ValueScope.scope()))
        {
            Exception::Raise(Exception::GetInvalidOperationException(${invokePapi('get_exception_as_string')}(ValueScope.scope(), true)));
            return nullptr;
        }
        return csRet;
    }
    return nullptr;
}

void SetObjectToGlobal(struct pesapi_ffi* apis, pesapi_env_ref envRef, Il2CppString* __key, Il2CppObject *obj)
{
    AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    
    const Il2CppChar* utf16 = il2cpp::utils::StringUtils::GetChars(__key);
    std::string key = il2cpp::utils::StringUtils::Utf16ToUtf8(utf16);
    
    pesapi_value global = ${invokePapi('global')}(env);
    if (global)
    {
        ${invokePapi('set_property')}(env, global, key.c_str(), CSRefToJsValue(apis, env, obj->klass, obj));
    }
}

#define EXECUTEMODULEGLOBANAME "__puertsExecuteModule"

Il2CppObject* GetModuleExecutor(struct pesapi_ffi* apis, intptr_t ptr, Il2CppReflectionType* rtype)
{
    pesapi_env_ref envRef = reinterpret_cast<pesapi_env_ref>(ptr);

    AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    
    pesapi_value global = ${invokePapi('global')}(env);
    if (!global)
    {
        Exception::Raise(Exception::GetInvalidOperationException("can not get global for env"));
        return nullptr;
    }
    
    pesapi_value func = ${invokePapi('get_property')}(env, global, EXECUTEMODULEGLOBANAME);
    if (!func)
    {
        Exception::Raise(Exception::GetInvalidOperationException("can not find ExecuteModule for env"));
        return nullptr;
    }

    auto type = il2cpp_codegen_class_from_type(rtype->type);
    return JsValueToCSRef(apis, type, env, func);
}

struct JsEnvPrivate
{
    struct pesapi_ffi* apis;
    pesapi_env_ref envRef;
    std::mutex pendingKillRefsMutex;
    std::unordered_set<pesapi_value_ref> pendingKillRefs;
    MethodInfoHelper<int32_t(Il2CppObject* obj)> objPoolAdd;
    MethodInfoHelper<Il2CppObject*(int32_t index)> objPoolRemove;
    
    JsEnvPrivate(struct pesapi_ffi* inApis, pesapi_env_ref inEnvRef, Il2CppObject *objPool, Il2CppReflectionMethod* objPoolAddMethodInfo, Il2CppReflectionMethod* objPoolRemoveMethodInfo)
        : apis(inApis), envRef(inEnvRef), objPoolAdd(objPoolAddMethodInfo->method, objPool), objPoolRemove(objPoolRemoveMethodInfo->method, objPool)
          
    {
    }
    
    void AddPendingKillScriptObjects(pesapi_value_ref valueRef)
    {
        uint32_t fieldCount;
        void** store = ${invokePapi('get_ref_internal_fields')}(valueRef, &fieldCount);
        if(fieldCount == internal_field_count_for_gc_handle && store)
        {
            std::lock_guard<std::mutex> guard(pendingKillRefsMutex);
            //PLog("AddPendingKillScriptObjects: %p", valueRef);
            pendingKillRefs.insert(valueRef);
        }
        //else
        //{
            // pesapi_value_ref not alloc by puerts?
            //${invokePapi('release_value_ref')}(valueRef);
        //}
    }
    
    void CleanupPendingKillScriptObjects()
    {
        AutoValueScope ValueScope(apis, envRef);
        auto env = ${invokePapi('get_env_from_ref')}(envRef);
        
        std::lock_guard<std::mutex> guard(pendingKillRefsMutex);
        auto size = pendingKillRefs.size();
        if (size == 0)
        {
            return;
        }
        
        for (const auto& valueRef : pendingKillRefs)
        {
            // insert前已经对有效性进行判断
            uint32_t fieldCount;
            //PLog("CleanupPendingKillScriptObjects: %p", valueRef);
            Il2CppGCHandle* store = reinterpret_cast<Il2CppGCHandle*>(${invokePapi('get_ref_internal_fields')}(valueRef, &fieldCount));
            Il2CppGCHandle handle = *store;
            if (nullptr == il2cpp::gc::GCHandle::GetTarget(handle)) //假如不为空代表已经重新被绑定了
            {
                il2cpp::gc::GCHandle::Free(handle);
                pesapi_value val = ${invokePapi('get_value_from_ref')}(env, valueRef);
                ${invokePapi('set_private')}(env, val, nullptr);
                ${invokePapi('release_value_ref')}(valueRef);
            }
        }

        pendingKillRefs.clear();
    }
    
    int32_t RefCSObject(Il2CppObject* obj)
    {
        return objPoolAdd.CallWithInstance(obj);
        //int32_t idx = objPoolAdd.CallWithInstance(obj);
        //PLog("RefCSObject(%s:%p) idx(%d)", obj->klass->name, obj, idx);
        //return idx;

    }

    void UnRefCSObject(int32_t idx)
    {
        objPoolRemove.CallWithInstance(idx);
        //auto obj = objPoolRemove.CallWithInstance(idx);
        //PLog("UnRefCSObject (%s:%p) idx(%d)", obj->klass->name, obj, idx);
    }
};

static void* OnCsObjectEnter(Il2CppObject* obj, void* class_data, JsEnvPrivate* jsEnvPrivate)
{
    return reinterpret_cast<void*>(jsEnvPrivate->RefCSObject(obj));
}

static void OnCsObjectExit(void* ptr, void* class_data, JsEnvPrivate* jsEnvPrivate, void* userdata)
{
    intptr_t idx = reinterpret_cast<intptr_t>(userdata);
    jsEnvPrivate->UnRefCSObject(idx);
}

static void FreeCSharpMethodInfo(CSharpMethodInfo* csharpMethodInfo)
{
    if (csharpMethodInfo)
    {
        for(int i = 0; i < csharpMethodInfo->OverloadDatas.size(); ++i)
        {
            free(csharpMethodInfo->OverloadDatas[i]);
        }
        delete csharpMethodInfo;
    }
}

static void FunctioFinalize(struct pesapi_ffi* apis, void* data, void* env_private)
{
    FreeCSharpMethodInfo((CSharpMethodInfo*) data);
}

static bool IsPrimitive(Il2CppTypeEnum type)
{
    return (type >= IL2CPP_TYPE_BOOLEAN && type <= IL2CPP_TYPE_R8) || type == IL2CPP_TYPE_I || type == IL2CPP_TYPE_U;
}

static bool TypeInfoPassToJsFilter(const Il2CppType* type, Il2CppClass* klass)
{
    return klass != il2cpp_defaults.void_class && !IsPrimitive(type->type) && IL2CPP_TYPE_ENUM != type->type && !Type::IsEnum(type) && Class::GetParent(klass) != il2cpp_defaults.enum_class;
}

static void SetParamArrayFlagAndOptionalNum(WrapData* data, const MethodInfo* method)
{
    data->HasParamArray = HasParamArray(method);
    data->OptionalNum = 0;
    
    for (uint32_t i = 0; i < method->parameters_count; ++i)
    {
        if (method->parameters[i]->attrs & PARAM_ATTRIBUTE_OPTIONAL)
        {
            ++data->OptionalNum;
        }
    }
}

static WrapData* CreateOverloadData(const MethodInfo* method, bool isExtensionMethod)
{
    bool isStatic = !Method::IsInstance(method) && !isExtensionMethod; 
    std::vector<Il2CppClass*> usedTypes;
    const Il2CppType* type = Method::GetReturnType(method);
    Il2CppClass* klass = il2cpp_codegen_class_from_type(type);
    if (TypeInfoPassToJsFilter(type, klass))
    {
        usedTypes.push_back(klass);
    }
    size_t paramCount = Method::GetParamCount(method);
    for (size_t index = isExtensionMethod ? 1 : 0; index < paramCount; ++index)
    {
        type = Method::GetParam(method, index);
        klass = il2cpp_codegen_class_from_type(type);
        if (TypeInfoPassToJsFilter(type, klass))
        {
            usedTypes.push_back(klass);
        }
    }
    int allocSize = sizeof(puerts::WrapData) + sizeof(void*) * usedTypes.size();
    puerts::WrapData* overloadData = (puerts::WrapData*)malloc(allocSize);
    memset(overloadData, 0, allocSize);
    overloadData->Method = const_cast<MethodInfo*>(method);
    overloadData->MethodPointer = GetMethodPointer(method);
    
    try
    {
        std::string signature = GetMethodSignature(method, false, isExtensionMethod);
        overloadData->Wrap = FindWrapFunc(signature.c_str());
    }
    catch (Il2CppExceptionWrapper& exception) { }
    if (!overloadData->Wrap)
    {
        overloadData->Wrap = &ReflectionWrapper;
    }
    SetParamArrayFlagAndOptionalNum(overloadData, method);
    overloadData->IsExtensionMethod = isExtensionMethod;
    overloadData->IsStatic = isStatic;
    memcpy(overloadData->TypeInfos, usedTypes.data(), sizeof(void*) * usedTypes.size());
    
    return overloadData;
}

static void createFunctionWrapper(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    pesapi_env env = ${invokePapi('get_env')}(info);
    int argc = ${invokePapi('get_args_len')}(info);
    CSharpMethodInfo* csharpMethodInfo = nullptr;
    for (int i = 0; i < argc; ++i)
    {
        Il2CppReflectionMethod* reflectionMethod = (Il2CppReflectionMethod*) ${invokePapi('get_native_object_ptr')}(env, ${invokePapi('get_arg')}(info, i));
        if (!reflectionMethod || !Class::IsAssignableFrom(il2cpp_defaults.method_info_class, reflectionMethod->object.klass))
        {
            ${invokePapi('throw_by_string')}(info, "expect a MethodInfo");
            FreeCSharpMethodInfo(csharpMethodInfo);
            return;
        }
        else
        {
            bool isStatic = !il2cpp::vm::Method::IsInstance(reflectionMethod->method);
            bool needBoxing = reflectionMethod->method->klass == il2cpp_defaults.object_class;
            if (csharpMethodInfo == nullptr)
            {
                csharpMethodInfo = new CSharpMethodInfo { std::string(reflectionMethod->method->name), isStatic, false, false, needBoxing};
            }
            csharpMethodInfo->OverloadDatas.push_back(CreateOverloadData(reflectionMethod->method, IsExtensionMethod(reflectionMethod->method)));
        }
    }
    if (csharpMethodInfo)
    {
        csharpMethodInfo->OverloadDatas.push_back(nullptr);
        auto func = ${invokePapi('create_function')}(env, MethodCallback, csharpMethodInfo, FunctioFinalize);
        ${invokePapi('add_return')}(info, func);
    }
}

static void LoadTypeWrapper(struct pesapi_ffi* apis, pesapi_callback_info info)
{
    pesapi_env env = ${invokePapi('get_env')}(info);
    Il2CppObject* type = (Il2CppObject*)${invokePapi('get_native_object_ptr')}(env,  ${invokePapi('get_arg')}(info, 0));
    auto type_id = CSharpTypeToTypeId(type);
    if (!type_id)
    {
        ${invokePapi('throw_by_string')}(info, "expect a Type");
        return;
    }
    auto ret = ${invokePapi('create_class')}(env, type_id);
    ${invokePapi('add_return')}(info, ret);
}

puerts::JsEnvPrivate* InitialPapiEnvRef(struct pesapi_ffi* apis, pesapi_env_ref envRef, Il2CppObject *objPool, Il2CppReflectionMethod* objPoolAddMethodInfo, Il2CppReflectionMethod* objPoolRemoveMethodInfo)
{
    puerts::AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    auto jsEnvPrivate = new puerts::JsEnvPrivate(apis, envRef, objPool, objPoolAddMethodInfo, objPoolRemoveMethodInfo);
    ${invokePapi('set_env_private')}(env, jsEnvPrivate);
    auto loadType = ${invokePapi('create_function')}(env, LoadTypeWrapper, nullptr, nullptr);
    auto createFunction = ${invokePapi('create_function')}(env, createFunctionWrapper, nullptr, nullptr);
    if (loadType && createFunction)
    {
        pesapi_value global = ${invokePapi('global')}(env);
        if (global)
        {
            ${invokePapi('set_property')}(env, global, "loadType", loadType);
            ${invokePapi('set_property')}(env, global, "createFunction", createFunction);
            pesapi_on_class_not_found(ClassNotFoundCallback);
            return jsEnvPrivate;
        }
    }
    Exception::Raise(Exception::GetInvalidOperationException("can not init global.loadType or global.createFunction"));
    return nullptr;
}

void CleanupPapiEnvRef(struct pesapi_ffi* apis, pesapi_env_ref envRef)
{
    puerts::AutoValueScope ValueScope(apis, envRef);
    auto env = ${invokePapi('get_env_from_ref')}(envRef);
    if (env)
    {
        auto jsEnvPrivate = (puerts::JsEnvPrivate*) ${invokePapi('get_env_private')}(env);
        jsEnvPrivate->CleanupPendingKillScriptObjects();
        // delete jsEnvPrivate;
        ${invokePapi('release_env_ref')}(envRef);
    }
}

void DestroyJSEnvPrivate(JsEnvPrivate* jsEnvPrivate)
{
    delete jsEnvPrivate;
}

Il2CppClass* GenericParamGetBaseType(Il2CppMetadataGenericParameterHandle gparam)
{
    Il2CppClass** constraints = Class::GetOrCreateMonoGenericParameterInfo(gparam)->constraints;

    Il2CppClass* base_class = il2cpp_defaults.object_class;

    if (constraints)
    {
        for (int i = 0; constraints[i]; ++i)
        {
            Il2CppClass* constraint = constraints[i];

            if (Class::IsInterface(constraint))
                continue;

            Il2CppType* constraint_type = &constraint->byval_arg;
            if (constraint_type->type == IL2CPP_TYPE_VAR || constraint_type->type == IL2CPP_TYPE_MVAR)
            {
                Il2CppMetadataGenericParameterHandle constraint_param = constraint_type->data.genericParameterHandle;
                Il2CppGenericParameterInfo constraint_info = MetadataCache::GetGenericParameterInfo(constraint_param);
                if ((constraint_info.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_REFERENCE_TYPE_CONSTRAINT) == 0 &&
                    (constraint_info.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_NOT_NULLABLE_VALUE_TYPE_CONSTRAINT) == 0)
                    continue;
            }

            base_class = constraint;
        }
    }

    if (base_class == il2cpp_defaults.object_class)
    {
        Il2CppGenericParameterInfo gparamInfo = MetadataCache::GetGenericParameterInfo(gparam);
        if ((gparamInfo.flags & IL2CPP_GENERIC_PARAMETER_ATTRIBUTE_NOT_NULLABLE_VALUE_TYPE_CONSTRAINT) != 0)
            base_class = il2cpp_defaults.value_type_class;
    }

    return base_class;
}

static const MethodInfo* MakeGenericMethodByConstraintedArguments(const MethodInfo* method)
{
    if (!Method::IsGeneric(method) || Method::IsInflated(method))
    {
        return method;
    }

    Il2CppMetadataGenericContainerHandle containerHandle = MetadataCache::GetGenericContainerFromMethod(method->methodMetadataHandle);

    uint32_t count = MetadataCache::GetGenericContainerCount(containerHandle);
    const Il2CppType** genericArguments = (const Il2CppType**)alloca(count * sizeof(Il2CppType*));

    for (uint32_t i = 0; i < count; i++)
    {
        Il2CppMetadataGenericParameterHandle param = GenericContainer::GetGenericParameter(containerHandle, i);
        //Il2CppClass* pklass = Class::FromGenericParameter(param);
        //genericArguments[i] = &(Class::GenericParamGetBaseType(pklass)->byval_arg); // debug 下 GenericParamGetBaseType对于IL2CPP_TYPE_MVAR，其is_generic_argument判断很奇怪：type->type == IL2CPP_TYPE_VAR || type->type == IL2CPP_TYPE_VAR，疑似笔误，从2022到6000都一样
        // 拷贝Class::GenericParamGetBaseType过来修改
        genericArguments[i] = &(GenericParamGetBaseType(param)->byval_arg);
    }
    return MetadataCache::GetGenericInstanceMethod(method, genericArguments, count);
}

static bool RegisterType(Il2CppClass* klass)
{
    Class::Init(klass);

    if (pesapi_get_class_data(klass, false))
    {
        return true;
    }

    bool isDelegate = IsDelegate(klass);

    JsClassInfo* classInfo = new JsClassInfo();
    classInfo->Name = klass->name;
    classInfo->TypeId = klass;
    classInfo->SuperTypeId = Class::GetParent(klass);
    classInfo->IsValueType = Class::IsValuetype(klass);

    auto AddMethod = [&](const MethodInfo* method, bool isGetter, bool isSetter, const char* name) -> bool
    {
        //const char* methodName = (isGetter || isSetter) ? name + 4 : name;
        bool isExtensionMethod = IsExtensionMethod(method);
        bool isStatic = !Method::IsInstance(method) && !isExtensionMethod; 
        for (int i = 0; i < classInfo->Methods.size(); ++i)
        {
            if (classInfo->Methods[i].IsStatic == isStatic && classInfo->Methods[i].IsGetter == isGetter && classInfo->Methods[i].IsSetter == isSetter && classInfo->Methods[i].Name == name)
            {
                if (isGetter || isSetter) // no overload for getter or setter
                {
                    return false;
                }
                classInfo->Methods[i].OverloadDatas.push_back(CreateOverloadData(method, isExtensionMethod));
                return true;
            }
        }
        std::vector<puerts::WrapData*> OverloadDatas;
        OverloadDatas.push_back(CreateOverloadData(method, isExtensionMethod));
        bool needBoxing = (isExtensionMethod ? GetParameterType(method, 0) : method->klass) == il2cpp_defaults.object_class;
        classInfo->Methods.push_back({ std::string(name), isStatic, isGetter, isSetter, needBoxing, std::move(OverloadDatas) });
        return true;
    };

    if (isDelegate)
    {
        MethodInfo* invoke = (MethodInfo*)il2cpp::vm::Class::GetMethodFromName(klass, "Invoke", -1);
        try
        {
            std::string signature = GetMethodSignature(invoke, true, false);
            classInfo->DelegateBridge = FindBridgeFunc(signature.c_str());
        }
        catch (Il2CppExceptionWrapper& exception)
        {
            return false;
        }
        AddMethod(invoke, false, false, "Invoke");
    }
    else
    {
        classInfo->DelegateBridge = nullptr;
        auto etype = klass->byval_arg.type;
        if (etype != IL2CPP_TYPE_SZARRAY && etype != IL2CPP_TYPE_ARRAY)
        {
            for (uint16_t i = 0; i < klass->method_count; ++i)
            {
                const MethodInfo* method = klass->methods[i];
                if (!IsCCtor(method) && !Method::IsGeneric(method))
                {
                    const char* name = method->name;
                    if (!(method->flags & METHOD_ATTRIBUTE_PUBLIC))
                    {
                        name = strrchr(name, '.'); // if Explicit Interface Implementation
                        if (!name) continue;
                        ++name;
                    }
                    bool isGetter = (method->flags & METHOD_ATTRIBUTE_SPECIAL_NAME) && strncmp("get_", name, 4) == 0 && method->parameters_count == 0;
                    bool isSetter = (method->flags & METHOD_ATTRIBUTE_SPECIAL_NAME) && strncmp("set_", name, 4) == 0 && method->parameters_count == 1;
                    name = (isGetter || isSetter) ? name + 4 : name;
                    if (IsCtor(method))
                    {
                        classInfo->Ctors.push_back(CreateOverloadData(method, false));
                    }
                    else
                    {
                        AddMethod(method, isGetter, isSetter, name);
                    }
                }
            }
            for (uint16_t i = 0; i < klass->field_count; i++)
            {
                FieldInfo* field = &klass->fields[i];
                bool isStatic = (field->type->attrs & FIELD_ATTRIBUTE_STATIC);
                std::string signature = (isStatic ? "" : "t");
                try
                {
                    signature += GetTypeSignature(field->type);
                }
                catch (Il2CppExceptionWrapper& exception)
                {
                    continue;
                }
                
                FieldWrapData* fieldData = new FieldWrapData();

                FieldWrapFuncPtr getter = &ReflectionGetFieldWrapper;
                FieldWrapFuncPtr setter = &ReflectionSetFieldWrapper;
                auto fieldWrapInfo = FindFieldWrapFuncInfo(signature.c_str());
                if (fieldWrapInfo)
                {
                    getter = fieldWrapInfo->Getter;
                    setter = fieldWrapInfo->Setter;
                }
                fieldData->Getter = getter;
                fieldData->Setter = setter;
                fieldData->FieldInfo = field;
                fieldData->Offset = (int32_t)Field::GetOffset(field) - (Class::IsValuetype(Field::GetParent(field)) ? sizeof(Il2CppObject) : 0);;
                fieldData->TypeInfo = Class::FromIl2CppType(field->type, false);;

                classInfo->Fields.push_back({ std::string(field->name), isStatic, fieldData });
            }
        }
        
        std::string assemblyQualifiedName(Type::GetName(&klass->byval_arg, IL2CPP_TYPE_NAME_FORMAT_ASSEMBLY_QUALIFIED));
        if (!assemblyQualifiedName.empty())
        {
            Il2CppArray* extensionMethods = g_ExtensionMethodGetHelper.Call(il2cpp::vm::String::NewWrapper(assemblyQualifiedName.c_str()));
            if (extensionMethods)
            {
                uint32_t len = Array::GetLength(extensionMethods);
                Il2CppReflectionMethod** arr = reinterpret_cast<Il2CppReflectionMethod**>(il2cpp::vm::Array::GetFirstElementAddress(extensionMethods));
                for (uint32_t i = 0; i < len; ++i)
                {
                    AddMethod(MakeGenericMethodByConstraintedArguments(arr[i]->method), false, false, arr[i]->method->name);
                }
            }
        }
    }

    classInfo->Ctors.push_back(nullptr);
    classInfo->CtorWrapDatas = classInfo->Ctors.data();

    std::map<std::string, std::pair<puerts::CSharpMethodInfo*, puerts::CSharpMethodInfo*>> gseters;
    std::vector<puerts::CSharpMethodInfo*> methods;

    for (auto& method : classInfo->Methods)
    {
        method.OverloadDatas.push_back(nullptr);

        if (method.IsGetter || method.IsSetter)
        {
            auto iter = gseters.find(method.Name);
            if (iter == gseters.end())
            {
                gseters[method.Name] = std::make_pair<puerts::CSharpMethodInfo*, puerts::CSharpMethodInfo*>(method.IsGetter ? &method : nullptr, method.IsSetter ? &method : nullptr);
            }
            else
            {
                if (method.IsGetter)
                {
                    iter->second.first = &method;
                }
                else
                {
                    iter->second.second = &method;
                }
            }
        }
        else
        {
            methods.push_back(&method);
        }
        //puerts::WrapData** wrapDatas = reinterpret_cast<puerts::WrapData**>(method.OverloadDatas.data());
    }

    size_t propertiesCount = gseters.size() + methods.size() + classInfo->Fields.size();
    auto properties = pesapi_alloc_property_descriptors(propertiesCount);
    size_t pos = 0;

    for (auto const& method : methods)
    {
        pesapi_set_method_info(
            properties, pos++, method->Name.c_str(), method->IsStatic, &MethodCallback, method, nullptr);
    }

    for (auto const& kv : gseters)
    {
        auto geter_or_setter = kv.second.first ? kv.second.first : kv.second.second;
        pesapi_set_property_info(properties, pos++, geter_or_setter->Name.c_str(), geter_or_setter->IsStatic,
            kv.second.first ? &MethodCallback : nullptr,
            kv.second.second ? &MethodCallback : nullptr,
            kv.second.first,
            kv.second.second,
            nullptr);
    }

    for (auto& field : classInfo->Fields)
    {
        pesapi_set_property_info(properties, pos++, field.Name.c_str(), field.IsStatic,
            GetterCallback, SetterCallback, field.Data, field.Data, nullptr);
    }

    pesapi_define_class(classInfo->TypeId, classInfo->SuperTypeId, classInfo->Name.c_str(),
        classInfo->DelegateBridge ? &DelegateCtorCallback : &CtorCallback, classInfo->IsValueType ? &PApiFree : (pesapi_finalize)nullptr, propertiesCount, properties, classInfo);

    if (!classInfo->IsValueType)
    {
        pesapi_trace_native_object_lifecycle(classInfo->TypeId, (pesapi_on_native_object_enter)&OnCsObjectEnter, (pesapi_on_native_object_exit)&OnCsObjectExit);
    }
    return true;
}


}

#ifdef __cplusplus
extern "C" {
#endif

void pesapi_init(pesapi_func_ptr* func_array);

void InitialPuerts(pesapi_func_ptr* func_array)
{
    InternalCalls::Add("Puerts.NativeAPI::SetGlobalType_TypedValue(System.Type)", (Il2CppMethodPointer)puerts::SetGlobalType_TypedValue);
    InternalCalls::Add("Puerts.NativeAPI::SetGlobalType_JSObject(System.Type)", (Il2CppMethodPointer)puerts::SetGlobalType_JSObject);
    InternalCalls::Add("Puerts.NativeAPI::SetGlobalType_ArrayBuffer(System.Type)", (Il2CppMethodPointer)puerts::SetGlobalType_ArrayBuffer);
    InternalCalls::Add("Puerts.NativeAPI::EvalInternal(System.IntPtr,System.IntPtr,System.Byte[],System.String,System.Type)", (Il2CppMethodPointer)puerts::EvalInternal);
    InternalCalls::Add("Puerts.NativeAPI::SetObjectToGlobal(System.IntPtr,System.IntPtr,System.String,System.Object)", (Il2CppMethodPointer)puerts::SetObjectToGlobal);
    InternalCalls::Add("Puerts.NativeAPI::GetModuleExecutor(System.IntPtr,System.IntPtr,System.Type)", (Il2CppMethodPointer)puerts::GetModuleExecutor);
    InternalCalls::Add("Puerts.NativeAPI::InitialPapiEnvRef(System.IntPtr,System.IntPtr,System.Object,System.Reflection.MethodBase,System.Reflection.MethodBase)", (Il2CppMethodPointer)puerts::InitialPapiEnvRef);
    InternalCalls::Add("Puerts.NativeAPI::CleanupPapiEnvRef(System.IntPtr,System.IntPtr)", (Il2CppMethodPointer)puerts::CleanupPapiEnvRef);
    InternalCalls::Add("Puerts.NativeAPI::DestroyJSEnvPrivate(System.IntPtr)", (Il2CppMethodPointer)puerts::DestroyJSEnvPrivate);
    InternalCalls::Add("Puerts.JSObject::GetJSObjectValue(System.IntPtr,System.String,System.Type)", (Il2CppMethodPointer)puerts::GetJSObjectValue);
    InternalCalls::Add("Puerts.NativeAPI::SetExtensionMethodGet(System.Reflection.MethodBase)", (Il2CppMethodPointer)puerts::SetExtensionMethodGet);
    pesapi_init(func_array);
    
    puerts::s_ParamArrayAttribute = Class::FromName(il2cpp_defaults.corlib, "System", "ParamArrayAttribute");
    puerts::s_ExtensionAttribute = Class::FromName(il2cpp_defaults.corlib, "System.Runtime.CompilerServices", "ExtensionAttribute");
}

void AddPendingKillScriptObjects(struct pesapi_ffi* apis, puerts::JsEnvPrivate* jsEnvPrivate, pesapi_value_ref valueRef)
{
    pesapi_env_ref envRef = ${invokePapi('get_ref_associated_env')}(valueRef);
    if (!${invokePapi('env_ref_is_valid')}(envRef)) // jsEnv已经释放
    {
        ${invokePapi('release_value_ref')}(valueRef);
        return;
    }
    jsEnvPrivate->AddPendingKillScriptObjects(valueRef);
}

void CleanupPendingKillScriptObjects(puerts::JsEnvPrivate* jsEnvPrivate)
{
    jsEnvPrivate->CleanupPendingKillScriptObjects();
}

void SetLogCallbackInternal(puerts::LogCallbackFunc Log)
{
    puerts::GLogCallback = Log;
}

#ifdef __cplusplus
}
#endif
